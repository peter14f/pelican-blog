<!DOCTYPE html>
<html lang="en" prefix="og: http://ogp.me/ns# fb: https://www.facebook.com/2008/fbml">
<head>
    <title>220-contains_duplicate_iii - Peter's Coding Notes</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">



<link rel="canonical" href="http://peter14f.github.io/pelican-blog/220-contains_duplicate_iii.html">

        <meta name="author" content="Peter Hsieh" />
        <meta name="description" content="LeetCode Problem Link To pass this on OJ, we need a data structure that have fast retrieval time and we need to be able to maintain ordering. In Java, using TreeMap&lt;Integer, Integer&gt; is the way to go. Need to worry about overflow for this problem. Call floorKey() to look for smaller keys. Call ceilingKey() to look for larger keys. The time complexity is O(nk log n)??? public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) { // key is the value stored in nums, value is the last seen index TreeMap&lt;Integer, Integer&gt; map = new TreeMap&lt;Integer, Integer&gt;(); for (int ..." />

        <meta property="og:site_name" content="Peter's Coding Notes" />
        <meta property="og:type" content="article"/>
        <meta property="og:title" content="220-contains_duplicate_iii"/>
        <meta property="og:url" content="http://peter14f.github.io/pelican-blog/220-contains_duplicate_iii.html"/>
        <meta property="og:description" content="LeetCode Problem Link To pass this on OJ, we need a data structure that have fast retrieval time and we need to be able to maintain ordering. In Java, using TreeMap&lt;Integer, Integer&gt; is the way to go. Need to worry about overflow for this problem. Call floorKey() to look for smaller keys. Call ceilingKey() to look for larger keys. The time complexity is O(nk log n)??? public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) { // key is the value stored in nums, value is the last seen index TreeMap&lt;Integer, Integer&gt; map = new TreeMap&lt;Integer, Integer&gt;(); for (int ..."/>
        <meta property="article:published_time" content="2016-02-02" />
            <meta property="article:section" content="LeetCode" />
            <meta property="article:author" content="Peter Hsieh" />


    <!-- Bootstrap -->
        <link rel="stylesheet" href="http://peter14f.github.io/pelican-blog/theme/css/bootstrap.min.css" type="text/css"/>
    <link href="http://peter14f.github.io/pelican-blog/theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="http://peter14f.github.io/pelican-blog/theme/css/pygments/native.css" rel="stylesheet">
    <link rel="stylesheet" href="http://peter14f.github.io/pelican-blog/theme/css/style.css" type="text/css"/>

        <link href="http://peter14f.github.io/pelican-blog/feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="Peter's Coding Notes ATOM Feed"/>



        <link href="http://peter14f.github.io/pelican-blog/feeds/leetcode.atom.xml" type="application/atom+xml" rel="alternate"
              title="Peter's Coding Notes LeetCode ATOM Feed"/>

</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
	<div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="http://peter14f.github.io/pelican-blog/" class="navbar-brand">
Peter's Coding Notes            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                        <li class="active">
                            <a href="http://peter14f.github.io/pelican-blog/category/leetcode.html">Leetcode</a>
                        </li>
                        <li >
                            <a href="http://peter14f.github.io/pelican-blog/category/misc.html">Misc</a>
                        </li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
              <li><a href="http://peter14f.github.io/pelican-blog/archives.html"><i class="fa fa-th-list"></i><span class="icon-label">Archives</span></a></li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->
<!-- Banner -->
<!-- End Banner -->
<div class="container">
    <div class="row">
        <div class="col-lg-12">
    <section id="content">
        <article>
                <h2>
                    <a href="http://peter14f.github.io/pelican-blog/220-contains_duplicate_iii.html"
                       rel="bookmark"
                       title="Permalink to 220-contains_duplicate_iii">
                        220-contains_duplicate_iii
                    </a>
                </h2>
            <div class="entry-content">
<footer class="post-info">
    <span class="published label label-default">
        <time datetime="2016-02-02T12:28:00-08:00"> Feb 02 2016</time>
    </span>





    
</footer><!-- /.post-info -->                <div class="full-article">
                <p><a class="reference external" href="https://leetcode.com/problems/contains-duplicate-iii/">LeetCode Problem Link</a></p>
<p>To pass this on OJ, we need a data structure that have fast retrieval time and we need to be able to
maintain ordering. In Java, using TreeMap&lt;Integer, Integer&gt; is the way to go.</p>
<p>Need to worry about overflow for this problem. Call <tt class="docutils literal">floorKey()</tt> to look for smaller keys. Call
<tt class="docutils literal">ceilingKey()</tt> to look for larger keys. The time complexity is O(nk log n)???</p>
<div class="highlight"><pre><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">containsNearbyAlmostDuplicate</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">,</span> <span class="kt">int</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// key is the value stored in nums, value is the last seen index</span>
    <span class="n">TreeMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;();</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="n">Integer</span> <span class="n">floorKey</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">floorKey</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">floorKey</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>

            <span class="kt">long</span> <span class="n">diff</span> <span class="o">=</span> <span class="o">(</span><span class="kt">long</span><span class="o">)</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">floorKey</span><span class="o">;</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">diff</span> <span class="o">&gt;</span> <span class="n">t</span><span class="o">)</span>
                <span class="k">break</span><span class="o">;</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">floorKey</span><span class="o">)</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="kt">int</span> <span class="n">nextSmaller</span> <span class="o">=</span> <span class="n">floorKey</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">nextSmaller</span> <span class="o">&gt;</span> <span class="n">floorKey</span><span class="o">)</span>
                <span class="k">break</span><span class="o">;</span>

            <span class="n">floorKey</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">floorKey</span><span class="o">(</span><span class="n">floorKey</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">nextBig</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]+</span><span class="mi">1</span><span class="o">;</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">nextBig</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">])</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>

        <span class="n">Integer</span> <span class="n">ceilingKey</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">ceilingKey</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">ceilingKey</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>

            <span class="kt">long</span> <span class="n">diff</span> <span class="o">=</span> <span class="o">(</span><span class="kt">long</span><span class="o">)</span><span class="n">ceilingKey</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">diff</span> <span class="o">&gt;</span> <span class="n">t</span><span class="o">)</span>
                <span class="k">break</span><span class="o">;</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">ceilingKey</span><span class="o">)</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="n">nextBig</span> <span class="o">=</span> <span class="n">ceilingKey</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nextBig</span> <span class="o">&lt;</span> <span class="n">ceilingKey</span><span class="o">)</span>
                <span class="k">break</span><span class="o">;</span>

            <span class="n">ceilingKey</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">ceilingKey</span><span class="o">(</span><span class="n">ceilingKey</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">i</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>

                </div>
            </div>
            <!-- /.entry-content -->
        </article>
    </section>

        </div>
    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">&copy; 2016 Peter Hsieh
            &middot; Powered by <a href="https://github.com/DandyDev/pelican-bootstrap3" target="_blank">pelican-bootstrap3</a>,
            <a href="http://docs.getpelican.com/" target="_blank">Pelican</a>,
            <a href="http://getbootstrap.com" target="_blank">Bootstrap</a>         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="http://peter14f.github.io/pelican-blog/theme/js/jquery.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="http://peter14f.github.io/pelican-blog/theme/js/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->
<script src="http://peter14f.github.io/pelican-blog/theme/js/respond.min.js"></script>


</body>
</html>