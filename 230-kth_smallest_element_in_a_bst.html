<!DOCTYPE html>
<html lang="en" prefix="og: http://ogp.me/ns# fb: https://www.facebook.com/2008/fbml">
<head>
    <title>230-kth_smallest_element_in_a_bst - Peter's Coding Notes</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">



<link rel="canonical" href="http://peter14f.github.io/pelican-blog/230-kth_smallest_element_in_a_bst.html">

        <meta name="author" content="Peter Hsieh" />
        <meta name="keywords" content="Binary Search Trees,Recursion" />
        <meta name="description" content="LeetCode Problem Link In the following approach, I basically use the iterative inorder traversal. Return the kth number once it&#39;s found. The time complexity is O(n) and the space complexity is O(h).ffsdfds public int kthSmallest(TreeNode root, int k) { int i = 0; Stack&lt;TreeNode&gt; stk = new Stack&lt;TreeNode&gt;(); TreeNode cur = root; while (!stk.isEmpty() || cur != null) { if (cur == null) { TreeNode top = stk.pop(); i++; if (i == k) return top.val; cur = top.right; } else { stk.push(cur); cur = cur.left; } } return Integer.MIN_VALUE; } This is a bad recursion. In the case of k=1, we have ..." />

        <meta property="og:site_name" content="Peter's Coding Notes" />
        <meta property="og:type" content="article"/>
        <meta property="og:title" content="230-kth_smallest_element_in_a_bst"/>
        <meta property="og:url" content="http://peter14f.github.io/pelican-blog/230-kth_smallest_element_in_a_bst.html"/>
        <meta property="og:description" content="LeetCode Problem Link In the following approach, I basically use the iterative inorder traversal. Return the kth number once it&#39;s found. The time complexity is O(n) and the space complexity is O(h).ffsdfds public int kthSmallest(TreeNode root, int k) { int i = 0; Stack&lt;TreeNode&gt; stk = new Stack&lt;TreeNode&gt;(); TreeNode cur = root; while (!stk.isEmpty() || cur != null) { if (cur == null) { TreeNode top = stk.pop(); i++; if (i == k) return top.val; cur = top.right; } else { stk.push(cur); cur = cur.left; } } return Integer.MIN_VALUE; } This is a bad recursion. In the case of k=1, we have ..."/>
        <meta property="article:published_time" content="2016-02-10" />
            <meta property="article:section" content="LeetCode" />
            <meta property="article:tag" content="Binary Search Trees" />
            <meta property="article:tag" content="Recursion" />
            <meta property="article:author" content="Peter Hsieh" />


    <!-- Bootstrap -->
        <link rel="stylesheet" href="http://peter14f.github.io/pelican-blog/theme/css/bootstrap.min.css" type="text/css"/>
    <link href="http://peter14f.github.io/pelican-blog/theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="http://peter14f.github.io/pelican-blog/theme/css/pygments/native.css" rel="stylesheet">
    <link rel="stylesheet" href="http://peter14f.github.io/pelican-blog/theme/css/style.css" type="text/css"/>

        <link href="http://peter14f.github.io/pelican-blog/feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="Peter's Coding Notes ATOM Feed"/>



        <link href="http://peter14f.github.io/pelican-blog/feeds/leetcode.atom.xml" type="application/atom+xml" rel="alternate"
              title="Peter's Coding Notes LeetCode ATOM Feed"/>

</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
	<div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="http://peter14f.github.io/pelican-blog/" class="navbar-brand">
Peter's Coding Notes            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                        <li class="active">
                            <a href="http://peter14f.github.io/pelican-blog/category/leetcode.html">Leetcode</a>
                        </li>
                        <li >
                            <a href="http://peter14f.github.io/pelican-blog/category/misc.html">Misc</a>
                        </li>
                        <li >
                            <a href="http://peter14f.github.io/pelican-blog/category/more-questions.html">More questions</a>
                        </li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
              <li><a href="http://peter14f.github.io/pelican-blog/archives.html"><i class="fa fa-th-list"></i><span class="icon-label">Archives</span></a></li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->
<!-- Banner -->
<!-- End Banner -->
<div class="container">
    <div class="row">
        <div class="col-lg-12">
    <section id="content">
        <article>
                <h2>
                    <a href="http://peter14f.github.io/pelican-blog/230-kth_smallest_element_in_a_bst.html"
                       rel="bookmark"
                       title="Permalink to 230-kth_smallest_element_in_a_bst">
                        230-kth_smallest_element_in_a_bst
                    </a>
                </h2>
            <div class="entry-content">
<footer class="post-info">
    <span class="published label label-default">
        <time datetime="2016-02-10T18:27:00-08:00"> Feb 10 2016</time>
    </span>





<span class="label label-default tag-lists">Tags</span>
	<a href="http://peter14f.github.io/pelican-blog/tag/binary-search-trees.html">Binary Search Trees</a>
        /
	<a href="http://peter14f.github.io/pelican-blog/tag/recursion.html">Recursion</a>
    
</footer><!-- /.post-info -->                <div class="full-article">
                <p><a class="reference external" href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/">LeetCode Problem Link</a></p>
<p>In the following approach, I basically use the iterative inorder traversal. Return the
kth number once it's found. The time complexity is O(n) and the space complexity is O(h).ffsdfds</p>
<div class="highlight"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">kthSmallest</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

  <span class="n">Stack</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">stk</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;();</span>
  <span class="n">TreeNode</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>

  <span class="k">while</span> <span class="o">(!</span><span class="n">stk</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">||</span> <span class="n">cur</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">cur</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">TreeNode</span> <span class="n">top</span> <span class="o">=</span> <span class="n">stk</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
      <span class="n">i</span><span class="o">++;</span>

      <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">k</span><span class="o">)</span>
        <span class="k">return</span> <span class="n">top</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>

      <span class="n">cur</span> <span class="o">=</span> <span class="n">top</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>

    <span class="o">}</span>
    <span class="k">else</span> <span class="o">{</span>
      <span class="n">stk</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">cur</span><span class="o">);</span>
      <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">return</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>
<p>This is a bad recursion. In the case of k=1, we have to repeated find the size of the trees over and over again.</p>
<p>I use recursion to solve the original problem. In the method, I find the size of the left subtree first. If the left
subtree has a size of <tt class="docutils literal">l</tt> and <tt class="docutils literal">k</tt> happens to be <tt class="docutils literal">l+1</tt>, then we know the root is the answer. If <tt class="docutils literal"><span class="pre">k&lt;=l</span></tt>, then
we know the answer is in the left subtree. If <tt class="docutils literal">k &gt; l+1</tt>, then we know the answer is in the right subtree.</p>
<div class="highlight"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">kthSmallest</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">leftSize</span> <span class="o">=</span> <span class="n">getTreeSize</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">leftSize</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">k</span><span class="o">)</span>
        <span class="k">return</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">&lt;=</span> <span class="n">leftSize</span><span class="o">)</span>
        <span class="k">return</span> <span class="n">kthSmallest</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">k</span><span class="o">);</span>

    <span class="k">return</span> <span class="n">kthSmallest</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">leftSize</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">int</span> <span class="nf">getTreeSize</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span>
        <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>

    <span class="kt">int</span> <span class="n">leftSize</span> <span class="o">=</span> <span class="n">getTreeSize</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
    <span class="kt">int</span> <span class="n">rightSize</span> <span class="o">=</span> <span class="n">getTreeSize</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>

    <span class="k">return</span> <span class="n">leftSize</span> <span class="o">+</span> <span class="n">rightSize</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>
<p>If you want to do this recursively. Here is the proper way of doing it.</p>
<div class="highlight"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">kthSmallest</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>

    <span class="kt">int</span><span class="o">[]</span> <span class="n">i</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">};</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">ans</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">};</span>

    <span class="n">inorderKth</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">k</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">ans</span><span class="o">);</span>

    <span class="k">return</span> <span class="n">ans</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">inorderKth</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">node</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">ans</span><span class="o">)</span> <span class="o">{</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span>
        <span class="k">return</span><span class="o">;</span>

    <span class="n">inorderKth</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">k</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">ans</span><span class="o">);</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">i</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="n">k</span><span class="o">)</span>
        <span class="k">return</span><span class="o">;</span>

    <span class="n">i</span><span class="o">[</span><span class="mi">0</span><span class="o">]++;</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">i</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="n">k</span><span class="o">)</span>
        <span class="n">ans</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>

    <span class="n">inorderKth</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">k</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">ans</span><span class="o">);</span>
<span class="o">}</span>
</pre></div>
<p>The follow-up asks for an optimization if the BST is inserting and deleting happens frequently.
The hint even says that we can modify the BST node structure.</p>
<p>What we will do is then keep another field in each node, <tt class="docutils literal">numLeftNodes</tt>. This is the number of nodes in the left
subtree. As long as we keep that field updated as we do insert and delete, we can guarantee that getting the
kth node takes O(h) time where <tt class="docutils literal">h</tt> is the height of the BST.</p>

                </div>
            </div>
            <!-- /.entry-content -->
        </article>
    </section>

        </div>
    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">&copy; 2018 Peter Hsieh
            &middot; Powered by <a href="https://github.com/DandyDev/pelican-bootstrap3" target="_blank">pelican-bootstrap3</a>,
            <a href="http://docs.getpelican.com/" target="_blank">Pelican</a>,
            <a href="http://getbootstrap.com" target="_blank">Bootstrap</a>         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="http://peter14f.github.io/pelican-blog/theme/js/jquery.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="http://peter14f.github.io/pelican-blog/theme/js/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->
<script src="http://peter14f.github.io/pelican-blog/theme/js/respond.min.js"></script>


</body>
</html>