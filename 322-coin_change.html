<!DOCTYPE html>
<html lang="en" prefix="og: http://ogp.me/ns# fb: https://www.facebook.com/2008/fbml">
<head>
    <title>322-coin_change - Peter's Coding Notes</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">



<link rel="canonical" href="http://peter14f.github.io/pelican-blog/322-coin_change.html">

        <meta name="author" content="Peter Hsieh" />
        <meta name="keywords" content="Knapsack Problem,Dynamic Programming,Unbounded Knapsack Problem,BFS" />
        <meta name="description" content="LeetCode Problem Link Compute the lowest number of coins needed to make up the amount specified. May assume that we have an infinite number of coins for each type of coins. Can we use a greedy algorithm since using the biggest denomination possible as many time as you can will lead you to the least number of coins. public int coinChange(int[] coins, int amount) { int numCoins = 0; int sum = 0; Arrays.sort(coins); for (int i=coins.length-1; i&gt;=0; i--) { while (sum + coins[i] &lt;= amount) { sum += coins[i]; numCoins++; } if (sum == amount) break; } if (sum != amount) return ..." />

        <meta property="og:site_name" content="Peter's Coding Notes" />
        <meta property="og:type" content="article"/>
        <meta property="og:title" content="322-coin_change"/>
        <meta property="og:url" content="http://peter14f.github.io/pelican-blog/322-coin_change.html"/>
        <meta property="og:description" content="LeetCode Problem Link Compute the lowest number of coins needed to make up the amount specified. May assume that we have an infinite number of coins for each type of coins. Can we use a greedy algorithm since using the biggest denomination possible as many time as you can will lead you to the least number of coins. public int coinChange(int[] coins, int amount) { int numCoins = 0; int sum = 0; Arrays.sort(coins); for (int i=coins.length-1; i&gt;=0; i--) { while (sum + coins[i] &lt;= amount) { sum += coins[i]; numCoins++; } if (sum == amount) break; } if (sum != amount) return ..."/>
        <meta property="article:published_time" content="2016-02-27" />
            <meta property="article:section" content="LeetCode" />
            <meta property="article:tag" content="Knapsack Problem" />
            <meta property="article:tag" content="Dynamic Programming" />
            <meta property="article:tag" content="Unbounded Knapsack Problem" />
            <meta property="article:tag" content="BFS" />
            <meta property="article:author" content="Peter Hsieh" />


    <!-- Bootstrap -->
        <link rel="stylesheet" href="http://peter14f.github.io/pelican-blog/theme/css/bootstrap.min.css" type="text/css"/>
    <link href="http://peter14f.github.io/pelican-blog/theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="http://peter14f.github.io/pelican-blog/theme/css/pygments/native.css" rel="stylesheet">
    <link rel="stylesheet" href="http://peter14f.github.io/pelican-blog/theme/css/style.css" type="text/css"/>

        <link href="http://peter14f.github.io/pelican-blog/feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="Peter's Coding Notes ATOM Feed"/>



        <link href="http://peter14f.github.io/pelican-blog/feeds/leetcode.atom.xml" type="application/atom+xml" rel="alternate"
              title="Peter's Coding Notes LeetCode ATOM Feed"/>

</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
	<div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="http://peter14f.github.io/pelican-blog/" class="navbar-brand">
Peter's Coding Notes            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                        <li class="active">
                            <a href="http://peter14f.github.io/pelican-blog/category/leetcode.html">Leetcode</a>
                        </li>
                        <li >
                            <a href="http://peter14f.github.io/pelican-blog/category/misc.html">Misc</a>
                        </li>
                        <li >
                            <a href="http://peter14f.github.io/pelican-blog/category/more-questions.html">More questions</a>
                        </li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
              <li><a href="http://peter14f.github.io/pelican-blog/archives.html"><i class="fa fa-th-list"></i><span class="icon-label">Archives</span></a></li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->
<!-- Banner -->
<!-- End Banner -->
<div class="container">
    <div class="row">
        <div class="col-lg-12">
    <section id="content">
        <article>
                <h2>
                    <a href="http://peter14f.github.io/pelican-blog/322-coin_change.html"
                       rel="bookmark"
                       title="Permalink to 322-coin_change">
                        322-coin_change
                    </a>
                </h2>
            <div class="entry-content">
<footer class="post-info">
    <span class="published label label-default">
        <time datetime="2016-02-27T16:13:00-08:00"> Feb 27 2016</time>
    </span>





<span class="label label-default tag-lists">Tags</span>
	<a href="http://peter14f.github.io/pelican-blog/tag/knapsack-problem.html">Knapsack Problem</a>
        /
	<a href="http://peter14f.github.io/pelican-blog/tag/dynamic-programming.html">Dynamic Programming</a>
        /
	<a href="http://peter14f.github.io/pelican-blog/tag/unbounded-knapsack-problem.html">Unbounded Knapsack Problem</a>
        /
	<a href="http://peter14f.github.io/pelican-blog/tag/bfs.html">BFS</a>
    
</footer><!-- /.post-info -->                <div class="full-article">
                <p><a class="reference external" href="https://leetcode.com/problems/coin-change/">LeetCode Problem Link</a></p>
<p>Compute the lowest number of coins needed to make up the amount specified.</p>
<p>May assume that we have an infinite number of coins for each type of coins.</p>
<p>Can we use a greedy algorithm since using the biggest denomination possible
as many time as you can will lead you to the least number of coins.</p>
<div class="highlight"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">coinChange</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">coins</span><span class="o">,</span> <span class="kt">int</span> <span class="n">amount</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">numCoins</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="n">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">coins</span><span class="o">);</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">coins</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">sum</span> <span class="o">+</span> <span class="n">coins</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">amount</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">coins</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="n">numCoins</span><span class="o">++;</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">sum</span> <span class="o">==</span> <span class="n">amount</span><span class="o">)</span>
            <span class="k">break</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">sum</span> <span class="o">!=</span> <span class="n">amount</span><span class="o">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>

    <span class="k">return</span> <span class="n">numCoins</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>
<pre class="literal-block">
44 / 180 test cases passed.
Status: Wrong Answer
Submitted: 0 minutes ago
Input:
[186,419,83,408]
6249
Output:
-1
Expected:
20
</pre>
<p>No, this won't work because after using as many of the biggest denomination as possible, you may be
left with a value that's smaller than any of the smaller denominations which will lead you to think
that there is no answer.</p>
<p>So this becomes a <em>combination sum</em> problem. Ie we follow the same idea but uses backtracking, then
the first answer found should be the one using the least amount of number</p>
<p>Well, I tried this and the first number of coins found this way is also not the right answer.</p>
<p>That means we must exhaust all possible ways and keep track the smallest number of coins used.</p>
<div class="highlight"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">coinChange</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">coins</span><span class="o">,</span> <span class="kt">int</span> <span class="n">amount</span><span class="o">)</span> <span class="o">{</span>

    <span class="n">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">coins</span><span class="o">);</span>

    <span class="c1">//System.out.println(Arrays.toString(coins));</span>

    <span class="kt">int</span><span class="o">[]</span> <span class="n">min</span> <span class="o">=</span> <span class="o">{</span><span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">};</span>

    <span class="n">findFirstCombinationSum</span><span class="o">(</span><span class="n">coins</span><span class="o">,</span> <span class="n">coins</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span>
                            <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">amount</span><span class="o">,</span> <span class="n">min</span><span class="o">);</span>

    <span class="k">return</span> <span class="n">min</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">findFirstCombinationSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">coins</span><span class="o">,</span> <span class="kt">int</span> <span class="n">coin</span><span class="o">,</span>
                                    <span class="kt">int</span> <span class="n">curSum</span><span class="o">,</span> <span class="kt">int</span> <span class="n">curCoins</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">,</span>
                                    <span class="kt">int</span><span class="o">[]</span> <span class="n">min</span><span class="o">)</span> <span class="o">{</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">coin</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//System.out.println(&quot;curSum=&quot; + curSum);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">curSum</span> <span class="o">==</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">curCoins</span> <span class="o">&lt;</span> <span class="n">min</span><span class="o">[</span><span class="mi">0</span><span class="o">])</span>
                <span class="n">min</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">curCoins</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="kt">int</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">target</span> <span class="o">-</span> <span class="n">curSum</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">mult</span> <span class="o">=</span> <span class="n">diff</span> <span class="o">/</span> <span class="n">coins</span><span class="o">[</span><span class="n">coin</span><span class="o">];</span>

    <span class="c1">// so you have (mult + 1) choices</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="n">mult</span><span class="o">;</span> <span class="n">k</span><span class="o">&gt;=</span><span class="mi">0</span><span class="o">;</span> <span class="n">k</span><span class="o">--)</span> <span class="o">{</span>

        <span class="kt">int</span> <span class="n">toAdd</span> <span class="o">=</span> <span class="n">coins</span><span class="o">[</span><span class="n">coin</span><span class="o">]</span> <span class="o">*</span> <span class="n">k</span><span class="o">;</span>

        <span class="n">findFirstCombinationSum</span><span class="o">(</span><span class="n">coins</span><span class="o">,</span> <span class="n">coin</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span>
                                <span class="n">curSum</span> <span class="o">+</span> <span class="n">toAdd</span><span class="o">,</span>
                                <span class="n">curCoins</span> <span class="o">+</span> <span class="n">k</span><span class="o">,</span> <span class="n">target</span><span class="o">,</span> <span class="n">min</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
<pre class="literal-block">
Submission Result: Time Limit Exceeded More Details

Last executed input:
[346,29,395,188,155,109]
9401
</pre>
<p>Alright. I know at least point, OJ is looking for a DP solution. At least I've got the correct answer to
check with.</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">dp[i][j]</span></tt> is the minimum number of coins needed to make up to the amount <tt class="docutils literal">j</tt> using the first <tt class="docutils literal">i</tt> coin</dt>
<dd>denominations.</dd>
</dl>
<p>i=1 the first coin denomination coins[0]
i=2 the first coin denomination coins[1]</p>
<p>and so on. By the way, this is some variation of the knapsack problem.</p>
<div class="highlight"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">coinChange</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">coins</span><span class="o">,</span> <span class="kt">int</span> <span class="n">amount</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[][]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">coins</span><span class="o">.</span><span class="na">length</span> <span class="o">+</span> <span class="mi">1</span><span class="o">][</span><span class="n">amount</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>

    <span class="n">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">coins</span><span class="o">);</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">coins</span><span class="o">));</span>

    <span class="c1">// first column</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">dp</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// first row</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;=</span><span class="n">amount</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// access the coin denomination with coins[i-1]</span>
    <span class="c1">//</span>
    <span class="c1">//</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">dp</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;=</span><span class="n">amount</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">minCoins</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>

            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">j</span><span class="o">/</span><span class="n">coins</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">k</span><span class="o">--)</span> <span class="o">{</span>


                <span class="kt">int</span> <span class="n">amountAfterK</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="o">(</span><span class="n">k</span><span class="o">*</span><span class="n">coins</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]);</span>


                <span class="cm">/*System.out.println(&quot;k=&quot; + k + &quot; amountAfterK=&quot; + amountAfterK + &quot; &quot; +</span>
<span class="cm">                                   dp[i-1][amountAfterK]);*/</span>

                <span class="kt">int</span> <span class="n">numCoins</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">amountAfterK</span><span class="o">];</span>

                <span class="c1">// overflow</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">numCoins</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
                    <span class="n">numCoins</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>

                <span class="n">minCoins</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">minCoins</span><span class="o">,</span> <span class="n">numCoins</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="c1">//System.out.println(&quot; min=&quot; + minCoins);</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">minCoins</span> <span class="o">==</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">)</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
            <span class="k">else</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">minCoins</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">//System.out.println(Arrays.deepToString(dp));</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">coins</span><span class="o">.</span><span class="na">length</span><span class="o">][</span><span class="n">amount</span><span class="o">]</span> <span class="o">==</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">coins</span><span class="o">.</span><span class="na">length</span><span class="o">][</span><span class="n">amount</span><span class="o">];</span>
<span class="o">}</span>
</pre></div>
<p>This approach is not optimal though. The inner loop over k turns out to be unnecessary.
Let <tt class="docutils literal">minCoinsToReach[i]</tt> be the minimum number of coins needed to reach amount <tt class="docutils literal">i</tt>.</p>
<p>If we already know <tt class="docutils literal"><span class="pre">minCoinsToReach[i-coin]</span></tt>, we just need to know if <tt class="docutils literal">1 + <span class="pre">minCoinsToReach[i-coin]</span></tt> is
smaller or if the current value of <tt class="docutils literal">minCoinsToReach[i]</tt> is smaller.</p>
<div class="highlight"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">coinChange2</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">coins</span><span class="o">,</span> <span class="kt">int</span> <span class="n">amount</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// dp[i] is the minimum number of coins to get the amount i</span>
    <span class="c1">//       -1 means not possible</span>
    <span class="kt">int</span> <span class="n">dp</span><span class="o">[]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">amount</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>

    <span class="c1">// sorting the input array allows us to break out from the inner loop early</span>
    <span class="n">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">coins</span><span class="o">);</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">amount</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">coin</span> <span class="o">:</span> <span class="n">coins</span><span class="o">)</span> <span class="o">{</span>
           <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">coin</span><span class="o">)</span> <span class="o">{</span>
               <span class="k">break</span><span class="o">;</span>
           <span class="o">}</span>
           <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">coin</span> <span class="o">&amp;&amp;</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="n">coin</span><span class="o">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
               <span class="n">min</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="n">coin</span><span class="o">],</span> <span class="n">min</span><span class="o">);</span>
           <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Set dp[i] to -1 if i (current amount) can not be reach by  coins array</span>
        <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="n">min</span> <span class="o">==</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">)</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">min</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">amount</span><span class="o">];</span>
<span class="o">}</span>
</pre></div>
<p>This last approach is a O(amount * n) time and O(amount) space.</p>
<p>You can also solve this problem with BFS. Start with amount and for each coin used
decrement the amount and put it into the queue. The number of coin denominations is
the number of neighbors each node has. And since we want to know the minimum number of coins
required, BFS is perfect for this since we can just break out from the loop as soon as
a node with zero amount is left. The time complexity of this approach would be
O(n ^ amount).</p>
<div class="highlight"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">coinChange</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">coins</span><span class="o">,</span> <span class="kt">int</span> <span class="n">amount</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">amount</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">numCoins</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="kt">boolean</span><span class="o">[]</span> <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">amount</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
    <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>
    <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">amount</span><span class="o">);</span>
    <span class="n">visited</span><span class="o">[</span><span class="n">amount</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

    <span class="k">while</span> <span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">size</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">coin</span> <span class="o">:</span> <span class="n">coins</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">newAmount</span> <span class="o">=</span> <span class="n">cur</span> <span class="o">-</span> <span class="n">coin</span><span class="o">;</span>

                <span class="k">if</span> <span class="o">(</span><span class="n">newAmount</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="n">numCoins</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">newAmount</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">visited</span><span class="o">[</span><span class="n">newAmount</span><span class="o">])</span> <span class="o">{</span>
                    <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">newAmount</span><span class="o">);</span>
                    <span class="n">visited</span><span class="o">[</span><span class="n">newAmount</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="n">numCoins</span><span class="o">++;</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>

                </div>
            </div>
            <!-- /.entry-content -->
        </article>
    </section>

        </div>
    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">&copy; 2018 Peter Hsieh
            &middot; Powered by <a href="https://github.com/DandyDev/pelican-bootstrap3" target="_blank">pelican-bootstrap3</a>,
            <a href="http://docs.getpelican.com/" target="_blank">Pelican</a>,
            <a href="http://getbootstrap.com" target="_blank">Bootstrap</a>         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="http://peter14f.github.io/pelican-blog/theme/js/jquery.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="http://peter14f.github.io/pelican-blog/theme/js/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->
<script src="http://peter14f.github.io/pelican-blog/theme/js/respond.min.js"></script>


</body>
</html>