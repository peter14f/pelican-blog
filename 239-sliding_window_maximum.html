<!DOCTYPE html>
<html lang="en" prefix="og: http://ogp.me/ns# fb: https://www.facebook.com/2008/fbml">
<head>
    <title>239-sliding_window_maximum - Peter's Coding Notes</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">



<link rel="canonical" href="http://peter14f.github.io/pelican-blog/239-sliding_window_maximum.html">

        <meta name="author" content="Peter Hsieh" />
        <meta name="keywords" content="Sliding Windows,Heap" />
        <meta name="description" content="LeetCode Problem Link The most straightforward solution take O(nk) time which simply uses two nested for loops to try to look for the max element in the current sliding window. // can assume k to be valid public int[] maxSlidingWindow(int[] nums, int k) { if (nums.length == 0) return nums; int[] output = new int[nums.length-k+1]; for (int i=0; i+k-1 &lt; nums.length; i++) { int max = nums[i]; for (int j=1; j&lt;k; j++) { if (nums[i+j] &gt; max) max = nums[i+j]; } output[i] = max; } return output; } The problem reminds me of 218-the_skyline_problem. We ..." />

        <meta property="og:site_name" content="Peter's Coding Notes" />
        <meta property="og:type" content="article"/>
        <meta property="og:title" content="239-sliding_window_maximum"/>
        <meta property="og:url" content="http://peter14f.github.io/pelican-blog/239-sliding_window_maximum.html"/>
        <meta property="og:description" content="LeetCode Problem Link The most straightforward solution take O(nk) time which simply uses two nested for loops to try to look for the max element in the current sliding window. // can assume k to be valid public int[] maxSlidingWindow(int[] nums, int k) { if (nums.length == 0) return nums; int[] output = new int[nums.length-k+1]; for (int i=0; i+k-1 &lt; nums.length; i++) { int max = nums[i]; for (int j=1; j&lt;k; j++) { if (nums[i+j] &gt; max) max = nums[i+j]; } output[i] = max; } return output; } The problem reminds me of 218-the_skyline_problem. We ..."/>
        <meta property="article:published_time" content="2016-02-16" />
            <meta property="article:section" content="LeetCode" />
            <meta property="article:tag" content="Sliding Windows" />
            <meta property="article:tag" content="Heap" />
            <meta property="article:author" content="Peter Hsieh" />


    <!-- Bootstrap -->
        <link rel="stylesheet" href="http://peter14f.github.io/pelican-blog/theme/css/bootstrap.min.css" type="text/css"/>
    <link href="http://peter14f.github.io/pelican-blog/theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="http://peter14f.github.io/pelican-blog/theme/css/pygments/native.css" rel="stylesheet">
    <link rel="stylesheet" href="http://peter14f.github.io/pelican-blog/theme/css/style.css" type="text/css"/>

        <link href="http://peter14f.github.io/pelican-blog/feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="Peter's Coding Notes ATOM Feed"/>



        <link href="http://peter14f.github.io/pelican-blog/feeds/leetcode.atom.xml" type="application/atom+xml" rel="alternate"
              title="Peter's Coding Notes LeetCode ATOM Feed"/>

</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
	<div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="http://peter14f.github.io/pelican-blog/" class="navbar-brand">
Peter's Coding Notes            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                        <li >
                            <a href="http://peter14f.github.io/pelican-blog/category/data-structures.html">Data structures</a>
                        </li>
                        <li >
                            <a href="http://peter14f.github.io/pelican-blog/category/java.html">Java</a>
                        </li>
                        <li class="active">
                            <a href="http://peter14f.github.io/pelican-blog/category/leetcode.html">Leetcode</a>
                        </li>
                        <li >
                            <a href="http://peter14f.github.io/pelican-blog/category/misc.html">Misc</a>
                        </li>
                        <li >
                            <a href="http://peter14f.github.io/pelican-blog/category/more-questions.html">More questions</a>
                        </li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
              <li><a href="http://peter14f.github.io/pelican-blog/archives.html"><i class="fa fa-th-list"></i><span class="icon-label">Archives</span></a></li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->
<!-- Banner -->
<!-- End Banner -->
<div class="container">
    <div class="row">
        <div class="col-lg-12">
    <section id="content">
        <article>
                <h2>
                    <a href="http://peter14f.github.io/pelican-blog/239-sliding_window_maximum.html"
                       rel="bookmark"
                       title="Permalink to 239-sliding_window_maximum">
                        239-sliding_window_maximum
                    </a>
                </h2>
            <div class="entry-content">
<footer class="post-info">
    <span class="published label label-default">
        <time datetime="2016-02-16T10:58:00-08:00"> Feb 16 2016</time>
    </span>





<span class="label label-default tag-lists">Tags</span>
	<a href="http://peter14f.github.io/pelican-blog/tag/sliding-windows.html">Sliding Windows</a>
        /
	<a href="http://peter14f.github.io/pelican-blog/tag/heap.html">Heap</a>
    
</footer><!-- /.post-info -->                <div class="full-article">
                <p><a class="reference external" href="https://leetcode.com/problems/sliding-window-maximum/">LeetCode Problem Link</a></p>
<p>The most straightforward solution take O(nk) time which simply uses two nested for loops to try to
look for the max element in the current sliding window.</p>
<div class="highlight"><pre><span class="c1">// can assume k to be valid</span>
<span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">maxSlidingWindow</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
        <span class="k">return</span> <span class="n">nums</span><span class="o">;</span>

    <span class="kt">int</span><span class="o">[]</span> <span class="n">output</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">+</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">k</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">max</span><span class="o">)</span>
                <span class="n">max</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="n">output</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">max</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">output</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>
<p>The problem reminds me of 218-the_skyline_problem. We could maintain a max heap of size <tt class="docutils literal">k</tt> so that getting the
maximum element within the sliding windows always takes O(logk) time. As the sliding windows gets moved forward one
slot, we need to remove one element from the heap and then insert one element into the heap. Such heap operations
were done in 218-the_skyline_problem.</p>
<p>This is the O(nlogk) time solution.</p>
<div class="highlight"><pre><span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">maxSlidingWindow</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
        <span class="k">return</span> <span class="n">nums</span><span class="o">;</span>

    <span class="n">PriorityQueue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">pq</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PriorityQueue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;(</span><span class="n">Collections</span><span class="o">.</span><span class="na">reverseOrder</span><span class="o">());</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">output</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">k</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="n">pq</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
    <span class="o">}</span>
    <span class="n">output</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="na">peek</span><span class="o">();</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">k</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">toRemove</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="o">];</span>
        <span class="n">pq</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">toRemove</span><span class="o">);</span>
        <span class="n">pq</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="n">output</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="na">peek</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">output</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>
<p>The follow-up question is the do this in O(n) time. The hint suggests using a deque (double-ended queue).
We use the dequeue to store the indices of elements in <tt class="docutils literal">nums</tt>.
The dequeue does not always contain <tt class="docutils literal">k</tt> elements. We only store the useful indices.</p>
<div class="highlight"><pre><span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">maxSlidingWindow</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
        <span class="k">return</span> <span class="n">nums</span><span class="o">;</span>

    <span class="kt">int</span><span class="o">[]</span> <span class="n">output</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>

    <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">dequeue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">k</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="k">while</span> <span class="o">(!</span><span class="n">dequeue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">nums</span><span class="o">[</span><span class="n">dequeue</span><span class="o">.</span><span class="na">getLast</span><span class="o">()])</span> <span class="o">{</span>
            <span class="n">dequeue</span><span class="o">.</span><span class="na">removeLast</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="n">dequeue</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="n">output</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">dequeue</span><span class="o">.</span><span class="na">getFirst</span><span class="o">()];</span>

    <span class="cm">/* Notice that the dequeue size always store &lt;= k indices */</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">k</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="k">while</span> <span class="o">(!</span><span class="n">dequeue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">nums</span><span class="o">[</span><span class="n">dequeue</span><span class="o">.</span><span class="na">getLast</span><span class="o">()])</span> <span class="o">{</span>
            <span class="n">dequeue</span><span class="o">.</span><span class="na">removeLast</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="k">while</span> <span class="o">(!</span><span class="n">dequeue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">dequeue</span><span class="o">.</span><span class="na">getFirst</span><span class="o">()</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">dequeue</span><span class="o">.</span><span class="na">removeFirst</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="n">dequeue</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="n">output</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">dequeue</span><span class="o">.</span><span class="na">getFirst</span><span class="o">()];</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">output</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>
<p>Each element's index is inserted and then removed at most once. So this algorithm takes O(n + n) = O(n) time.</p>
<p>We only store the index of <strong>previous numbers bigger than the new number</strong> in the dequeue. But we also get rid of
bigger numbers already that's too old to be in the current window.</p>
<pre class="literal-block">
DEUQUEU only stores the index of older numbers that are &gt; new number

front &lt;--------------   --------------&gt; back
the smaller the index   the bigger the index


The front of the DEQUEUE always contains the max element in the window
</pre>

                </div>
            </div>
            <!-- /.entry-content -->
        </article>
    </section>

        </div>
    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">&copy; 2018 Peter Hsieh
            &middot; Powered by <a href="https://github.com/DandyDev/pelican-bootstrap3" target="_blank">pelican-bootstrap3</a>,
            <a href="http://docs.getpelican.com/" target="_blank">Pelican</a>,
            <a href="http://getbootstrap.com" target="_blank">Bootstrap</a>         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="http://peter14f.github.io/pelican-blog/theme/js/jquery.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="http://peter14f.github.io/pelican-blog/theme/js/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->
<script src="http://peter14f.github.io/pelican-blog/theme/js/respond.min.js"></script>


</body>
</html>