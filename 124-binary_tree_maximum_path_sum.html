<!DOCTYPE html>
<html lang="en" prefix="og: http://ogp.me/ns# fb: https://www.facebook.com/2008/fbml">
<head>
    <title>124-binary_tree_maximum_path_sum - Peter's Coding Notes</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">



<link rel="canonical" href="http://peter14f.github.io/pelican-blog/124-binary_tree_maximum_path_sum.html">

        <meta name="author" content="Peter Hsieh" />
        <meta name="keywords" content="Recursion,Binary Trees" />
        <meta name="description" content="LeetCode Problem Link For this problem, a path must contain at least one node in the binary tree unless the I want to do DFS, but we are missing the parent link. One way we could solve this problem is build a HashMap to find the parent of a node and then perform DFS from each and every node. But this takes exponential time and will not pass the large test case on OJ. public int maxPathSum(TreeNode root) { if (root==null) return 0; if (root.left == null &amp;&amp; root.right == null) { return root.val; } HashMap&lt;TreeNode, TreeNode&gt; parents = new HashMap ..." />

        <meta property="og:site_name" content="Peter's Coding Notes" />
        <meta property="og:type" content="article"/>
        <meta property="og:title" content="124-binary_tree_maximum_path_sum"/>
        <meta property="og:url" content="http://peter14f.github.io/pelican-blog/124-binary_tree_maximum_path_sum.html"/>
        <meta property="og:description" content="LeetCode Problem Link For this problem, a path must contain at least one node in the binary tree unless the I want to do DFS, but we are missing the parent link. One way we could solve this problem is build a HashMap to find the parent of a node and then perform DFS from each and every node. But this takes exponential time and will not pass the large test case on OJ. public int maxPathSum(TreeNode root) { if (root==null) return 0; if (root.left == null &amp;&amp; root.right == null) { return root.val; } HashMap&lt;TreeNode, TreeNode&gt; parents = new HashMap ..."/>
        <meta property="article:published_time" content="2015-12-01" />
            <meta property="article:section" content="LeetCode" />
            <meta property="article:tag" content="Recursion" />
            <meta property="article:tag" content="Binary Trees" />
            <meta property="article:author" content="Peter Hsieh" />


    <!-- Bootstrap -->
        <link rel="stylesheet" href="http://peter14f.github.io/pelican-blog/theme/css/bootstrap.min.css" type="text/css"/>
    <link href="http://peter14f.github.io/pelican-blog/theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="http://peter14f.github.io/pelican-blog/theme/css/pygments/native.css" rel="stylesheet">
    <link rel="stylesheet" href="http://peter14f.github.io/pelican-blog/theme/css/style.css" type="text/css"/>

        <link href="http://peter14f.github.io/pelican-blog/feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="Peter's Coding Notes ATOM Feed"/>



        <link href="http://peter14f.github.io/pelican-blog/feeds/leetcode.atom.xml" type="application/atom+xml" rel="alternate"
              title="Peter's Coding Notes LeetCode ATOM Feed"/>

</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
	<div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="http://peter14f.github.io/pelican-blog/" class="navbar-brand">
Peter's Coding Notes            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                        <li class="active">
                            <a href="http://peter14f.github.io/pelican-blog/category/leetcode.html">Leetcode</a>
                        </li>
                        <li >
                            <a href="http://peter14f.github.io/pelican-blog/category/misc.html">Misc</a>
                        </li>
                        <li >
                            <a href="http://peter14f.github.io/pelican-blog/category/more-questions.html">More questions</a>
                        </li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
              <li><a href="http://peter14f.github.io/pelican-blog/archives.html"><i class="fa fa-th-list"></i><span class="icon-label">Archives</span></a></li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->
<!-- Banner -->
<!-- End Banner -->
<div class="container">
    <div class="row">
        <div class="col-lg-12">
    <section id="content">
        <article>
                <h2>
                    <a href="http://peter14f.github.io/pelican-blog/124-binary_tree_maximum_path_sum.html"
                       rel="bookmark"
                       title="Permalink to 124-binary_tree_maximum_path_sum">
                        124-binary_tree_maximum_path_sum
                    </a>
                </h2>
            <div class="entry-content">
<footer class="post-info">
    <span class="published label label-default">
        <time datetime="2015-12-01T21:02:00-08:00"> Dec 01 2015</time>
    </span>





<span class="label label-default tag-lists">Tags</span>
	<a href="http://peter14f.github.io/pelican-blog/tag/recursion.html">Recursion</a>
        /
	<a href="http://peter14f.github.io/pelican-blog/tag/binary-trees.html">Binary Trees</a>
    
</footer><!-- /.post-info -->                <div class="full-article">
                <p><a class="reference external" href="https://leetcode.com/problems/binary-tree-maximum-path-sum/">LeetCode Problem Link</a></p>
<p>For this problem, a path must contain at least one node in the binary tree unless the</p>
<p>I want to do DFS, but we are missing the parent link. One way we could solve this problem is build a HashMap to find
the parent of a node and then perform DFS from each and every node. But this takes exponential time and will not pass
the large test case on OJ.</p>
<div class="highlight"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxPathSum</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span>
        <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">,</span> <span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">parents</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">,</span> <span class="n">TreeNode</span><span class="o">&gt;();</span>
    <span class="n">buildParentMap</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="n">parents</span><span class="o">);</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">nodes</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;();</span>
    <span class="n">nodes</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>

    <span class="k">for</span> <span class="o">(</span><span class="n">TreeNode</span> <span class="n">n</span><span class="o">:</span> <span class="n">parents</span><span class="o">.</span><span class="na">keySet</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">nodes</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kt">int</span><span class="o">[]</span> <span class="n">maxSum</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">};</span>

    <span class="k">for</span> <span class="o">(</span><span class="n">TreeNode</span> <span class="n">n</span><span class="o">:</span> <span class="n">nodes</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;();</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">visited</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">maxSum</span><span class="o">,</span> <span class="n">parents</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">maxSum</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
<span class="o">}</span>
</pre></div>
<p>Here is another approach that does not require starting the dfs from every node. The method <tt class="docutils literal">maxPathSum</tt> that takes
two arguments returns the maximum path sum including the <tt class="docutils literal">node</tt> node that can be extended. So which paths can
contain the <tt class="docutils literal">node</tt> and can be extended?</p>
<blockquote>
<ol class="arabic simple">
<li>path containing the node only</li>
<li>path containing the node and the max path containing its left child node</li>
<li>path containing the node and the max path containing its right child node</li>
</ol>
</blockquote>
<p>Tha maximum of the above three values will be returned by <tt class="docutils literal">maxPathSum</tt>.</p>
<p>Note that the path containing the node <strong>plus</strong> the max path containing its left child node <strong>plus</strong> the max path
containing its right child node <strong>CANNOT</strong> be further expanded. So this is why we also pass in an int[] <tt class="docutils literal">max</tt> into
<tt class="docutils literal">maxPathSum</tt>. We still calculate the sum for this path and if it exceeds <tt class="docutils literal">max[0]</tt>, <tt class="docutils literal">max[0]</tt> will be overwritten.
We just don't return the this value.</p>
<p>Since the of a path for this problem must contain at this one node. We initialize <tt class="docutils literal">max[0]</tt> to <tt class="docutils literal">root.val</tt>.
Each node in the binary tree is visited once so this takes O(n) time. The space complexity is O(n) which is number of
function calls on the stack in the worst case.</p>
<div class="highlight"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxPathSum</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span>
        <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>

    <span class="c1">// the path must contain one node at least</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">max</span> <span class="o">=</span> <span class="o">{</span><span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">};</span>

    <span class="kt">int</span> <span class="n">me</span> <span class="o">=</span> <span class="n">maxPathSum</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">max</span><span class="o">);</span>

    <span class="k">return</span> <span class="n">max</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">int</span> <span class="nf">maxPathSum</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">node</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">max</span><span class="o">)</span> <span class="o">{</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">val</span> <span class="o">&gt;</span> <span class="n">max</span><span class="o">[</span><span class="mi">0</span><span class="o">])</span>
            <span class="n">max</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>

        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">int</span> <span class="n">leftMax</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">rightMax</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">;</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">leftMax</span> <span class="o">=</span> <span class="n">maxPathSum</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">max</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">rightMax</span> <span class="o">=</span> <span class="n">maxPathSum</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">max</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kt">int</span> <span class="n">selfOnly</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>

    <span class="kt">int</span> <span class="n">plusLeft</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">val</span> <span class="o">+</span> <span class="n">leftMax</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">leftMax</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="o">.</span><span class="na">val</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">plusLeft</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
        <span class="n">plusLeft</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">;</span>

    <span class="kt">int</span> <span class="n">plusRight</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">val</span> <span class="o">+</span> <span class="n">rightMax</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">rightMax</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="o">.</span><span class="na">val</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">plusRight</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
        <span class="n">plusRight</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">;</span>

    <span class="kt">int</span> <span class="n">includeNode</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">selfOnly</span><span class="o">,</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">plusLeft</span><span class="o">,</span> <span class="n">plusRight</span><span class="o">));</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">includeNode</span> <span class="o">&gt;</span> <span class="n">max</span><span class="o">[</span><span class="mi">0</span><span class="o">])</span> <span class="o">{</span>
        <span class="n">max</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">includeNode</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">int</span> <span class="n">cannotExtend</span> <span class="o">=</span> <span class="n">plusLeft</span> <span class="o">+</span> <span class="n">rightMax</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">plusLeft</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">rightMax</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">cannotExtend</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
        <span class="n">cannotExtend</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">;</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">cannotExtend</span> <span class="o">&gt;</span> <span class="n">max</span><span class="o">[</span><span class="mi">0</span><span class="o">])</span>
        <span class="n">max</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">cannotExtend</span><span class="o">;</span>

    <span class="k">return</span> <span class="n">includeNode</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>

                </div>
            </div>
            <!-- /.entry-content -->
        </article>
    </section>

        </div>
    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">&copy; 2018 Peter Hsieh
            &middot; Powered by <a href="https://github.com/DandyDev/pelican-bootstrap3" target="_blank">pelican-bootstrap3</a>,
            <a href="http://docs.getpelican.com/" target="_blank">Pelican</a>,
            <a href="http://getbootstrap.com" target="_blank">Bootstrap</a>         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="http://peter14f.github.io/pelican-blog/theme/js/jquery.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="http://peter14f.github.io/pelican-blog/theme/js/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->
<script src="http://peter14f.github.io/pelican-blog/theme/js/respond.min.js"></script>


</body>
</html>