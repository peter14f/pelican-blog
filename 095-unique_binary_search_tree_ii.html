<!DOCTYPE html>
<html lang="en" prefix="og: http://ogp.me/ns# fb: https://www.facebook.com/2008/fbml">
<head>
    <title>095-unique_binary_search_tree_ii - Peter's Coding Notes</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">



<link rel="canonical" href="http://peter14f.github.io/pelican-blog/095-unique_binary_search_tree_ii.html">

        <meta name="author" content="Peter Hsieh" />
        <meta name="keywords" content="Binary Search Trees,Recursion,Dynamic Programming,Cloning Trees" />
        <meta name="description" content="LeetCode Problem Link The problem is similar to 096-unique_binary_search_trees in that we must get the solution to n from the solution to n-1. The tricky part is that we cannot just simply clone the BSTs. We must provide a mapping. What do I mean by this? The BST with one node we find the ArrayList will be the node containing the value 1. But in the case of having a total of two nodes and when the root is 1, the right subBST must be the node containing the value 2 instead of the value 1. public List&lt;TreeNode&gt; generateTrees ..." />

        <meta property="og:site_name" content="Peter's Coding Notes" />
        <meta property="og:type" content="article"/>
        <meta property="og:title" content="095-unique_binary_search_tree_ii"/>
        <meta property="og:url" content="http://peter14f.github.io/pelican-blog/095-unique_binary_search_tree_ii.html"/>
        <meta property="og:description" content="LeetCode Problem Link The problem is similar to 096-unique_binary_search_trees in that we must get the solution to n from the solution to n-1. The tricky part is that we cannot just simply clone the BSTs. We must provide a mapping. What do I mean by this? The BST with one node we find the ArrayList will be the node containing the value 1. But in the case of having a total of two nodes and when the root is 1, the right subBST must be the node containing the value 2 instead of the value 1. public List&lt;TreeNode&gt; generateTrees ..."/>
        <meta property="article:published_time" content="2015-11-19" />
            <meta property="article:section" content="LeetCode" />
            <meta property="article:tag" content="Binary Search Trees" />
            <meta property="article:tag" content="Recursion" />
            <meta property="article:tag" content="Dynamic Programming" />
            <meta property="article:tag" content="Cloning Trees" />
            <meta property="article:author" content="Peter Hsieh" />


    <!-- Bootstrap -->
        <link rel="stylesheet" href="http://peter14f.github.io/pelican-blog/theme/css/bootstrap.min.css" type="text/css"/>
    <link href="http://peter14f.github.io/pelican-blog/theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="http://peter14f.github.io/pelican-blog/theme/css/pygments/native.css" rel="stylesheet">
    <link rel="stylesheet" href="http://peter14f.github.io/pelican-blog/theme/css/style.css" type="text/css"/>

        <link href="http://peter14f.github.io/pelican-blog/feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="Peter's Coding Notes ATOM Feed"/>



        <link href="http://peter14f.github.io/pelican-blog/feeds/leetcode.atom.xml" type="application/atom+xml" rel="alternate"
              title="Peter's Coding Notes LeetCode ATOM Feed"/>

</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
	<div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="http://peter14f.github.io/pelican-blog/" class="navbar-brand">
Peter's Coding Notes            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                        <li >
                            <a href="http://peter14f.github.io/pelican-blog/category/data-structures.html">Data structures</a>
                        </li>
                        <li >
                            <a href="http://peter14f.github.io/pelican-blog/category/java.html">Java</a>
                        </li>
                        <li class="active">
                            <a href="http://peter14f.github.io/pelican-blog/category/leetcode.html">Leetcode</a>
                        </li>
                        <li >
                            <a href="http://peter14f.github.io/pelican-blog/category/misc.html">Misc</a>
                        </li>
                        <li >
                            <a href="http://peter14f.github.io/pelican-blog/category/more-questions.html">More questions</a>
                        </li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
              <li><a href="http://peter14f.github.io/pelican-blog/archives.html"><i class="fa fa-th-list"></i><span class="icon-label">Archives</span></a></li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->
<!-- Banner -->
<!-- End Banner -->
<div class="container">
    <div class="row">
        <div class="col-lg-12">
    <section id="content">
        <article>
                <h2>
                    <a href="http://peter14f.github.io/pelican-blog/095-unique_binary_search_tree_ii.html"
                       rel="bookmark"
                       title="Permalink to 095-unique_binary_search_tree_ii">
                        095-unique_binary_search_tree_ii
                    </a>
                </h2>
            <div class="entry-content">
<footer class="post-info">
    <span class="published label label-default">
        <time datetime="2015-11-19T21:30:00-08:00"> Nov 19 2015</time>
    </span>





<span class="label label-default tag-lists">Tags</span>
	<a href="http://peter14f.github.io/pelican-blog/tag/binary-search-trees.html">Binary Search Trees</a>
        /
	<a href="http://peter14f.github.io/pelican-blog/tag/recursion.html">Recursion</a>
        /
	<a href="http://peter14f.github.io/pelican-blog/tag/dynamic-programming.html">Dynamic Programming</a>
        /
	<a href="http://peter14f.github.io/pelican-blog/tag/cloning-trees.html">Cloning Trees</a>
    
</footer><!-- /.post-info -->                <div class="full-article">
                <p><a class="reference external" href="https://leetcode.com/problems/unique-binary-search-trees-ii/">LeetCode Problem Link</a></p>
<p>The problem is similar to 096-unique_binary_search_trees in that we must get the solution to <tt class="docutils literal">n</tt> from the
solution to <tt class="docutils literal"><span class="pre">n-1</span></tt>. The tricky part is that we cannot just simply clone the BSTs. We must provide a mapping.</p>
<p>What do I mean by this? The BST with one node we find the ArrayList will be the node containing the value <tt class="docutils literal">1</tt>. But
in the case of having a total of two nodes and when the root is <tt class="docutils literal">1</tt>, the right subBST must be the node containing
the value <tt class="docutils literal">2</tt> instead of the value <tt class="docutils literal">1</tt>.</p>
<div class="highlight"><pre><span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="nf">generateTrees</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>

    <span class="n">List</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">empty</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">n</span><span class="o">==</span><span class="mi">0</span><span class="o">)</span>
        <span class="k">return</span> <span class="n">empty</span><span class="o">;</span>

    <span class="n">empty</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>

    <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;&gt;</span> <span class="n">bstNodes</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;&gt;();</span>


    <span class="n">bstNodes</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">empty</span><span class="o">);</span> <span class="c1">// 0 nodes</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">numNodes</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">numNodes</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">;</span> <span class="n">numNodes</span><span class="o">++)</span> <span class="o">{</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">cur</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;();</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">r</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">r</span><span class="o">&lt;=</span><span class="n">numNodes</span><span class="o">;</span> <span class="n">r</span><span class="o">++)</span> <span class="o">{</span>


            <span class="kt">int</span> <span class="n">numLeftSubBSTNodes</span> <span class="o">=</span> <span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
            <span class="n">List</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">leftSubBSTs</span> <span class="o">=</span> <span class="n">bstNodes</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">numLeftSubBSTNodes</span><span class="o">);</span>
            <span class="kt">int</span> <span class="n">numRightSubBSTNodes</span> <span class="o">=</span> <span class="n">numNodes</span> <span class="o">-</span> <span class="n">r</span><span class="o">;</span>
            <span class="n">List</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">rightSubBSTs</span> <span class="o">=</span> <span class="n">bstNodes</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">numRightSubBSTNodes</span><span class="o">);</span>

            <span class="k">for</span> <span class="o">(</span><span class="n">TreeNode</span> <span class="n">bst1</span><span class="o">:</span> <span class="n">leftSubBSTs</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">for</span> <span class="o">(</span><span class="n">TreeNode</span> <span class="n">bst2</span><span class="o">:</span> <span class="n">rightSubBSTs</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">TreeNode</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="o">(</span><span class="n">r</span><span class="o">);</span>
                    <span class="n">TreeNode</span> <span class="n">cloneLeft</span> <span class="o">=</span> <span class="n">cloneTree</span><span class="o">(</span><span class="n">bst1</span><span class="o">,</span> <span class="n">numLeftSubBSTNodes</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">r</span><span class="o">);</span>
                    <span class="n">TreeNode</span> <span class="n">cloneRight</span> <span class="o">=</span> <span class="n">cloneTree</span><span class="o">(</span><span class="n">bst2</span><span class="o">,</span> <span class="n">numRightSubBSTNodes</span><span class="o">,</span> <span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">numNodes</span><span class="o">,</span> <span class="n">r</span><span class="o">);</span>
                    <span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">cloneLeft</span><span class="o">;</span>
                    <span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">cloneRight</span><span class="o">;</span>
                    <span class="n">cur</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="n">bstNodes</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">cur</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">bstNodes</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="n">TreeNode</span> <span class="nf">cloneTree</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">bst</span><span class="o">,</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">bst</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>

    <span class="n">TreeNode</span> <span class="n">cur</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">bst</span><span class="o">.</span><span class="na">val</span><span class="o">));</span>
    <span class="n">cur</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">cloneTree</span><span class="o">(</span><span class="n">bst</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">map</span><span class="o">);</span>
    <span class="n">cur</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">cloneTree</span><span class="o">(</span><span class="n">bst</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">map</span><span class="o">);</span>

    <span class="k">return</span> <span class="n">cur</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="n">TreeNode</span> <span class="nf">cloneTree</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">bst</span><span class="o">,</span> <span class="kt">int</span> <span class="n">num</span><span class="o">,</span> <span class="kt">int</span> <span class="n">low</span><span class="o">,</span> <span class="kt">int</span> <span class="n">high</span><span class="o">,</span> <span class="kt">int</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">bst</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>

    <span class="c1">// old tree contains 1 through num,</span>
    <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;();</span>

    <span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">low</span><span class="o">;</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">num</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">j</span><span class="o">==</span><span class="n">root</span><span class="o">)</span>
            <span class="n">j</span><span class="o">++;</span>

        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">);</span>
        <span class="n">j</span><span class="o">++;</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">cloneTree</span><span class="o">(</span><span class="n">bst</span><span class="o">,</span> <span class="n">map</span><span class="o">);</span>
<span class="o">}</span>
</pre></div>
<p>The recursive solution turns out to be way cleaner.</p>
<div class="highlight"><pre><span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="nf">generateTrees</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">n</span><span class="o">==</span><span class="mi">0</span><span class="o">)</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;();</span>

    <span class="k">return</span> <span class="n">generateTrees</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="nf">generateTrees</span><span class="o">(</span><span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>

    <span class="n">List</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">bsts</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;();</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">bsts</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">r</span><span class="o">=</span><span class="n">start</span><span class="o">;</span> <span class="n">r</span><span class="o">&lt;=</span><span class="n">end</span><span class="o">;</span> <span class="n">r</span><span class="o">++)</span> <span class="o">{</span>

        <span class="n">List</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">lefts</span> <span class="o">=</span> <span class="n">generateTrees</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">rights</span> <span class="o">=</span> <span class="n">generateTrees</span><span class="o">(</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">end</span><span class="o">);</span>

        <span class="k">for</span> <span class="o">(</span><span class="n">TreeNode</span> <span class="n">left</span><span class="o">:</span> <span class="n">lefts</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="n">TreeNode</span> <span class="n">right</span><span class="o">:</span> <span class="n">rights</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">TreeNode</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="o">(</span><span class="n">r</span><span class="o">);</span>
                <span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span>
                <span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">;</span>
                <span class="n">bsts</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

    <span class="o">}</span>

    <span class="k">return</span> <span class="n">bsts</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>
<p>Revisited the problem on 03/04/2016. Still doing the iterative approach, it turns out the mapping for cloning
the right subtree is not all that complicated. Since the right subBST must contain bigger values that the current
<tt class="docutils literal">root</tt> value, we just need to add <tt class="docutils literal">root</tt> to all the node values when cloning.</p>
<div class="highlight"><pre><span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="nf">generateTrees</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">n</span><span class="o">==</span><span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;();</span>
    <span class="o">}</span>

    <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;&gt;</span> <span class="n">trees</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;&gt;();</span>

    <span class="n">trees</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;());</span>
    <span class="n">trees</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="na">add</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>

    <span class="c1">// i is the number of nodes in the tree</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="n">trees</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;());</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">root</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">root</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="o">;</span> <span class="n">root</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">leftSize</span> <span class="o">=</span> <span class="n">root</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">rightSize</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">root</span><span class="o">;</span>

            <span class="n">List</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">leftTrees</span> <span class="o">=</span> <span class="n">trees</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">leftSize</span><span class="o">);</span>
            <span class="n">List</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">rightTrees</span> <span class="o">=</span> <span class="n">trees</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">rightSize</span><span class="o">);</span>

            <span class="k">for</span> <span class="o">(</span><span class="n">TreeNode</span> <span class="n">l</span> <span class="o">:</span> <span class="n">leftTrees</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">for</span> <span class="o">(</span><span class="n">TreeNode</span> <span class="n">r</span> <span class="o">:</span> <span class="n">rightTrees</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">TreeNode</span> <span class="n">rootNode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>

                    <span class="n">rootNode</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">l</span><span class="o">;</span>
                    <span class="n">rootNode</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">cloneTree</span><span class="o">(</span><span class="n">r</span><span class="o">,</span> <span class="n">root</span><span class="o">);</span>

                    <span class="n">trees</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">add</span><span class="o">(</span><span class="n">rootNode</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="c1">// try all root values from 1 up to i</span>
    <span class="o">}</span> <span class="c1">// for i</span>

    <span class="k">return</span> <span class="n">trees</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="n">TreeNode</span> <span class="nf">cloneTree</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="kt">int</span> <span class="n">toAdd</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>

    <span class="n">TreeNode</span> <span class="n">newRoot</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span> <span class="o">+</span> <span class="n">toAdd</span><span class="o">);</span>

    <span class="n">newRoot</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">cloneTree</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">toAdd</span><span class="o">);</span>
    <span class="n">newRoot</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">cloneTree</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">toAdd</span><span class="o">);</span>

    <span class="k">return</span> <span class="n">newRoot</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>

                </div>
            </div>
            <!-- /.entry-content -->
        </article>
    </section>

        </div>
    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">&copy; 2018 Peter Hsieh
            &middot; Powered by <a href="https://github.com/DandyDev/pelican-bootstrap3" target="_blank">pelican-bootstrap3</a>,
            <a href="http://docs.getpelican.com/" target="_blank">Pelican</a>,
            <a href="http://getbootstrap.com" target="_blank">Bootstrap</a>         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="http://peter14f.github.io/pelican-blog/theme/js/jquery.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="http://peter14f.github.io/pelican-blog/theme/js/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->
<script src="http://peter14f.github.io/pelican-blog/theme/js/respond.min.js"></script>


</body>
</html>