<!DOCTYPE html>
<html lang="en" prefix="og: http://ogp.me/ns# fb: https://www.facebook.com/2008/fbml">
<head>
    <title>314-binary_tree_vertical_order_traversal - Peter's Coding Notes</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">



<link rel="canonical" href="http://peter14f.github.io/pelican-blog/314-binary_tree_vertical_order_traversal.html">

        <meta name="author" content="Peter Hsieh" />
        <meta name="keywords" content="Binary Trees,Binary Tree Traversals" />
        <meta name="description" content="LeetCode Problem Link If we think of the root as in a horizontal position of 0. It&#39;s left child would be in position -1, and it&#39;s right child would be in position 1. We could get the position of children given the position of the current node. Using recursion, I can store the current node into the list that matches its position. We can use a HashMap&lt;Integer, List&lt;TreeNode&gt;&gt; to store all the lists. The key is simply the position. First Attempt public List&lt;List&lt;Integer&gt;&gt; verticalOrder(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; allLists = new ArrayList&lt;List&lt;Integer ..." />

        <meta property="og:site_name" content="Peter's Coding Notes" />
        <meta property="og:type" content="article"/>
        <meta property="og:title" content="314-binary_tree_vertical_order_traversal"/>
        <meta property="og:url" content="http://peter14f.github.io/pelican-blog/314-binary_tree_vertical_order_traversal.html"/>
        <meta property="og:description" content="LeetCode Problem Link If we think of the root as in a horizontal position of 0. It&#39;s left child would be in position -1, and it&#39;s right child would be in position 1. We could get the position of children given the position of the current node. Using recursion, I can store the current node into the list that matches its position. We can use a HashMap&lt;Integer, List&lt;TreeNode&gt;&gt; to store all the lists. The key is simply the position. First Attempt public List&lt;List&lt;Integer&gt;&gt; verticalOrder(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; allLists = new ArrayList&lt;List&lt;Integer ..."/>
        <meta property="article:published_time" content="2016-02-26" />
            <meta property="article:section" content="LeetCode" />
            <meta property="article:tag" content="Binary Trees" />
            <meta property="article:tag" content="Binary Tree Traversals" />
            <meta property="article:author" content="Peter Hsieh" />


    <!-- Bootstrap -->
        <link rel="stylesheet" href="http://peter14f.github.io/pelican-blog/theme/css/bootstrap.min.css" type="text/css"/>
    <link href="http://peter14f.github.io/pelican-blog/theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="http://peter14f.github.io/pelican-blog/theme/css/pygments/native.css" rel="stylesheet">
    <link rel="stylesheet" href="http://peter14f.github.io/pelican-blog/theme/css/style.css" type="text/css"/>

        <link href="http://peter14f.github.io/pelican-blog/feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="Peter's Coding Notes ATOM Feed"/>



        <link href="http://peter14f.github.io/pelican-blog/feeds/leetcode.atom.xml" type="application/atom+xml" rel="alternate"
              title="Peter's Coding Notes LeetCode ATOM Feed"/>

</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
	<div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="http://peter14f.github.io/pelican-blog/" class="navbar-brand">
Peter's Coding Notes            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                        <li class="active">
                            <a href="http://peter14f.github.io/pelican-blog/category/leetcode.html">Leetcode</a>
                        </li>
                        <li >
                            <a href="http://peter14f.github.io/pelican-blog/category/misc.html">Misc</a>
                        </li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
              <li><a href="http://peter14f.github.io/pelican-blog/archives.html"><i class="fa fa-th-list"></i><span class="icon-label">Archives</span></a></li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->
<!-- Banner -->
<!-- End Banner -->
<div class="container">
    <div class="row">
        <div class="col-lg-12">
    <section id="content">
        <article>
                <h2>
                    <a href="http://peter14f.github.io/pelican-blog/314-binary_tree_vertical_order_traversal.html"
                       rel="bookmark"
                       title="Permalink to 314-binary_tree_vertical_order_traversal">
                        314-binary_tree_vertical_order_traversal
                    </a>
                </h2>
            <div class="entry-content">
<footer class="post-info">
    <span class="published label label-default">
        <time datetime="2016-02-26T09:15:00-08:00"> Feb 26 2016</time>
    </span>





<span class="label label-default tag-lists">Tags</span>
	<a href="http://peter14f.github.io/pelican-blog/tag/binary-trees.html">Binary Trees</a>
        /
	<a href="http://peter14f.github.io/pelican-blog/tag/binary-tree-traversals.html">Binary Tree Traversals</a>
    
</footer><!-- /.post-info -->                <div class="full-article">
                <p><a class="reference external" href="https://leetcode.com/problems/binary-tree-vertical-order-traversal/">LeetCode Problem Link</a></p>
<p>If we think of the root as in a horizontal position of <tt class="docutils literal">0</tt>. It's left child would be in position <tt class="docutils literal"><span class="pre">-1</span></tt>, and
it's right child would be in position <tt class="docutils literal">1</tt>. We could get the position of children given the position of the
current node.</p>
<p>Using recursion, I can store the current node into the list that matches its position.
We can use a <tt class="docutils literal">HashMap&lt;Integer, List&lt;TreeNode&gt;&gt;</tt> to store all the lists. The key is simply the position.</p>
<p>First Attempt</p>
<div class="highlight"><pre><span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">verticalOrder</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">allLists</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;();</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span>
        <span class="k">return</span> <span class="n">allLists</span><span class="o">;</span>

    <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;();</span>

    <span class="n">addNodeToItsList</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">map</span><span class="o">);</span>

    <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">positions</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;(</span><span class="n">map</span><span class="o">.</span><span class="na">keySet</span><span class="o">());</span>

    <span class="n">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">positions</span><span class="o">);</span>

    <span class="c1">// traverse the position in order</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">pos</span><span class="o">:</span> <span class="n">positions</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">allLists</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">pos</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">allLists</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">addNodeToItsList</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">node</span><span class="o">,</span> <span class="kt">int</span> <span class="n">position</span><span class="o">,</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">map</span><span class="o">)</span> <span class="o">{</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span>
        <span class="k">return</span><span class="o">;</span>

    <span class="k">if</span> <span class="o">(!</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">position</span><span class="o">))</span> <span class="o">{</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">position</span><span class="o">,</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;());</span>
    <span class="o">}</span>

    <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">position</span><span class="o">).</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>

    <span class="c1">// got to go to left first according to the problem statement:</span>
    <span class="c1">//   If two nodes are in the same row and column,</span>
    <span class="c1">//   the order should be from left to right.</span>

    <span class="n">addNodeToItsList</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">position</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">map</span><span class="o">);</span>
    <span class="n">addNodeToItsList</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">position</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">map</span><span class="o">);</span>
<span class="o">}</span>
</pre></div>
<pre class="literal-block">
Input:
[5,1,6,null,3,null,null,2,4]
Output:
[[1,2],[5,3],[4,6]]
Expected:
[[1,2],[5,3],[6,4]]
</pre>
<p>So it looks like nodes in the same column but different rows must be in the order of the rows.
Does that mean we should pass down the vertical position from root as well?</p>
<p>Wait a minute, perhaps we should we BFS instead DFS.
That way, we are guaranteed that the upper nodes are added into the list first.</p>
<div class="highlight"><pre><span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">verticalOrder</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">allLists</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;();</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span>
        <span class="k">return</span> <span class="n">allLists</span><span class="o">;</span>

    <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">posLookup</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;();</span>
    <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">listLookup</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;();</span>

    <span class="n">posLookup</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>

    <span class="n">Queue</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;();</span>
    <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>

    <span class="c1">// with a binary tree we don&#39;t need to worry about coming back</span>
    <span class="c1">// to current node because the child does not have a parent pointer</span>

    <span class="k">while</span> <span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">TreeNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>

        <span class="kt">int</span> <span class="n">position</span> <span class="o">=</span> <span class="n">posLookup</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>

        <span class="k">if</span> <span class="o">(!</span><span class="n">listLookup</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">position</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">newList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
            <span class="n">listLookup</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">position</span><span class="o">,</span> <span class="n">newList</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="n">listLookup</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">position</span><span class="o">).</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">posLookup</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">position</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
            <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">posLookup</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">position</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
            <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">positions</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;(</span><span class="n">listLookup</span><span class="o">.</span><span class="na">keySet</span><span class="o">());</span>
    <span class="n">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">positions</span><span class="o">);</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">pos</span><span class="o">:</span> <span class="n">positions</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">allLists</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">listLookup</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">pos</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">allLists</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>
<p>One the the observation I made when doing BFS on a graph is that we've got to make sure that we don't
end up going back to a node that we've been to. With BFS on a binary tree, we don't actually need to worry
about this because the nodes in a binary tree do not have a reference to the parent node.</p>

                </div>
            </div>
            <!-- /.entry-content -->
        </article>
    </section>

        </div>
    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">&copy; 2016 Peter Hsieh
            &middot; Powered by <a href="https://github.com/DandyDev/pelican-bootstrap3" target="_blank">pelican-bootstrap3</a>,
            <a href="http://docs.getpelican.com/" target="_blank">Pelican</a>,
            <a href="http://getbootstrap.com" target="_blank">Bootstrap</a>         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="http://peter14f.github.io/pelican-blog/theme/js/jquery.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="http://peter14f.github.io/pelican-blog/theme/js/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->
<script src="http://peter14f.github.io/pelican-blog/theme/js/respond.min.js"></script>


</body>
</html>