a03-sort_squares_in_place
#########################

:date: 2016-3-14 10:43
:tags: Two Pointers
:category:
:slug: a03-sort_squares_in_place

::

    Given a sorted int array. We want to know the squares of the array in sorted order.
    Do this in-place.


We will use two pointers ``left`` and ``right`` for this problem.

Say the input array ``nums`` is of size ``n``.

``left`` is initialized at ``0``.
``right`` is initialized at ``n-1``.


The key observation is that the next largest square must always be
generated by doing ``nums[left] * nums[left]`` or
``nums[right] * nums[right]``

.. code-block:: java

    public void sortSquaresInPlace(int[] nums) {

        if (nums.length==0)
            return;

        int left = 0;
        int right = nums.length - 1;

        while (left <= right) {

            if (Math.abs(nums[right]) >= Math.abs(nums[left])) {
                nums[right] = nums[right]*nums[right];
                right--;
            }
            else {
                nums[left] = nums[left]*nums[left];
                swap(nums, left, right);

                right--;

                // the next largest square must be generated from nums[left]*nums[left]
                // or nums[right] * nums[right]
                //
                // but after the swap nums[left+1]*nums[left+1] could actually be larger than
                // nums[left]*nums[left]
                
                if (left + 1 <= right &&
                    Math.abs(nums[left+1]) > Math.abs(nums[left])) {

                    swap(nums, left, left+1);

                }
            }
        }
    }

    private void swap(int[] nums, int i, int j) {
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }

I've run the following inputs

[0, 0, 0]
[1, 2, 3, 4]
[-1, 0, 1]
[-4, -3, -2, -1]
[-4,-2,0, 2, 4]

