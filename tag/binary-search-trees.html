<!DOCTYPE html>
<html lang="en" prefix="og: http://ogp.me/ns# fb: https://www.facebook.com/2008/fbml">
<head>
    <title>Binary Search Trees - Peter's Coding Notes</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">




    <meta name="author" content="Peter Hsieh" />
    <meta name="keywords" content="Binary Search Trees" />

    <!-- Open Graph tags -->
        <meta property="og:site_name" content="Peter's Coding Notes" />
        <meta property="og:type" content="website"/>
        <meta property="og:title" content="Peter's Coding Notes"/>
        <meta property="og:url" content="http://peter14f.github.io/pelican-blog"/>
        <meta property="og:description" content="Peter's Coding Notes"/>


    <!-- Bootstrap -->
        <link rel="stylesheet" href="http://peter14f.github.io/pelican-blog/theme/css/bootstrap.min.css" type="text/css"/>
    <link href="http://peter14f.github.io/pelican-blog/theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="http://peter14f.github.io/pelican-blog/theme/css/pygments/native.css" rel="stylesheet">
    <link rel="stylesheet" href="http://peter14f.github.io/pelican-blog/theme/css/style.css" type="text/css"/>

        <link href="http://peter14f.github.io/pelican-blog/feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="Peter's Coding Notes ATOM Feed"/>




</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
	<div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="http://peter14f.github.io/pelican-blog/" class="navbar-brand">
Peter's Coding Notes            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                        <li >
                            <a href="http://peter14f.github.io/pelican-blog/category/leetcode.html">Leetcode</a>
                        </li>
                        <li >
                            <a href="http://peter14f.github.io/pelican-blog/category/misc.html">Misc</a>
                        </li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
              <li><a href="http://peter14f.github.io/pelican-blog/archives.html"><i class="fa fa-th-list"></i><span class="icon-label">Archives</span></a></li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->
<!-- Banner -->
<!-- End Banner -->
<div class="container">
    <div class="row">
        <div class="col-lg-12">
            <article>
                <h2 class="article-title"><a href="http://peter14f.github.io/pelican-blog/272-closest_binary_search_tree_value_ii.html">272-closest_binary_search_tree_value_ii</a></h2>
                    <div>
<footer class="post-info">
    <span class="published label label-default">
        <time datetime="2016-02-20T11:18:00-08:00"> Feb 20 2016</time>
    </span>





<span class="label label-default tag-lists">Tags</span>
	<a href="http://peter14f.github.io/pelican-blog/tag/binary-search-trees.html">Binary Search Trees</a>
        /
	<a href="http://peter14f.github.io/pelican-blog/tag/closest-value-in-bst.html">Closest Value In BST</a>
    
</footer><!-- /.post-info -->                    </div>
                <div class="summary article-summary"><p><a class="reference external" href="https://leetcode.com/problems/closest-binary-search-tree-value-ii/">LeetCode Problem Link</a></p>
<p>The problem seems very intimidating at first. Reading the followup question right away does not help either.</p>
<p>What you need is to use a simple BST as an example.</p>
<pre class="literal-block">
      7
     / \
    5   8
   /     \
  3       10
 /         \
1          25
</pre>
<p>Say <tt class="docutils literal">target</tt> is 7 and <tt class="docutils literal">k</tt> is 4, the the answer should be</p>
<pre class="literal-block">
[7, 5, 8, 10]
</pre>
<p>The straightforward solution would be first get the preorder traversal of the BST.
We know that the preorder traversal results in a sorted list.
In this case, the preorder traversal results in</p>
<pre class="literal-block">
[1, 3, 5, 7, 8, 10, 25]
</pre>
<p>Find the element closest to ...</p>
                    <a class="btn btn-default btn-xs" href="http://peter14f.github.io/pelican-blog/272-closest_binary_search_tree_value_ii.html">more ...</a>
                </div>
            </article>
            <hr/>
            <article>
                <h2 class="article-title"><a href="http://peter14f.github.io/pelican-blog/270-closest_binary_search_tree_value.html">270-closest_binary_search_tree_value</a></h2>
                    <div>
<footer class="post-info">
    <span class="published label label-default">
        <time datetime="2016-02-19T23:13:00-08:00"> Feb 19 2016</time>
    </span>





<span class="label label-default tag-lists">Tags</span>
	<a href="http://peter14f.github.io/pelican-blog/tag/binary-search-trees.html">Binary Search Trees</a>
        /
	<a href="http://peter14f.github.io/pelican-blog/tag/closest-value-in-bst.html">Closest Value In BST</a>
    
</footer><!-- /.post-info -->                    </div>
                <div class="summary article-summary"><p><a class="reference external" href="https://leetcode.com/problems/closest-binary-search-tree-value/">LeetCode Problem Link</a></p>
<p>Record the closest element traversed so far and the minimum difference.</p>
<p>The iterative approach definitely makes more sense here.</p>
<p>Just because the diff is greater than the min diff, it does not mean you should stop there. Continue with the BST
search.</p>
<div class="highlight"><pre><span class="c1">// tree is non-empty</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">closestValue</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="kt">double</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>

    <span class="n">TreeNode</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
    <span class="kt">double</span> <span class="n">minDiff</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span> <span class="o">-</span> <span class="n">target</span><span class="o">);</span>
    <span class="kt">int</span> <span class="n">curVal</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>

    <span class="k">while</span> <span class="o">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">double</span> <span class="n">myDiff</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">val</span> <span class="o">-</span> <span class="n">target</span><span class="o">);</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">myDiff</span> <span class="o">&lt;</span> <span class="n">minDiff</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">minDiff</span> <span class="o">=</span> <span class="n">myDiff</span><span class="o">;</span>
            <span class="n">curVal</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">val</span> <span class="o">==</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">val</span> <span class="o">&gt;</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// too big</span>
            <span class="n">cur ...</span></pre></div>
                    <a class="btn btn-default btn-xs" href="http://peter14f.github.io/pelican-blog/270-closest_binary_search_tree_value.html">more ...</a>
                </div>
            </article>
            <hr/>
            <article>
                <h2 class="article-title"><a href="http://peter14f.github.io/pelican-blog/255-verify_preorder_sequence_in_binary_search_tree.html">255-verify_preorder_sequence_in_binary_search_tree</a></h2>
                    <div>
<footer class="post-info">
    <span class="published label label-default">
        <time datetime="2016-02-18T13:34:00-08:00"> Feb 18 2016</time>
    </span>





<span class="label label-default tag-lists">Tags</span>
	<a href="http://peter14f.github.io/pelican-blog/tag/binary-search-trees.html">Binary Search Trees</a>
        /
	<a href="http://peter14f.github.io/pelican-blog/tag/inorder-traversal.html">Inorder Traversal</a>
    
</footer><!-- /.post-info -->                    </div>
                <div class="summary article-summary"><p><a class="reference external" href="https://leetcode.com/problems/verify-preorder-sequence-in-binary-search-tree/">LeetCode Problem Link</a></p>
<p>In a preorder traversal sequence, the first element is always the root. The first element you find that is greater
than root marks the beginning of the right subtree. All elements starting from it must be greater than root. Then
we must use recursion to check the left subtree and the right subtree.</p>
<div class="highlight"><pre><span class="c1">// could assume each number in the sequence is unique</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">verifyPreorder</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">preorder</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">preorder</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>

    <span class="k">return</span> <span class="n">isPreorder</span><span class="o">(</span><span class="n">preorder</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">preorder</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isPreorder</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">preorder</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">start</span><span class="o">==</span><span class="n">end</span><span class="o">)</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>

    <span class="kt">int</span> <span class="n">root</span> <span class="o">=</span> <span class="n">preorder ...</span></pre></div>
                    <a class="btn btn-default btn-xs" href="http://peter14f.github.io/pelican-blog/255-verify_preorder_sequence_in_binary_search_tree.html">more ...</a>
                </div>
            </article>
            <hr/>
            <article>
                <h2 class="article-title"><a href="http://peter14f.github.io/pelican-blog/235-lowest_common_ancestor_of_a_binary_search_tree.html">235-lowest_common_ancestor_of_a_binary_search_tree</a></h2>
                    <div>
<footer class="post-info">
    <span class="published label label-default">
        <time datetime="2016-02-13T23:28:00-08:00"> Feb 13 2016</time>
    </span>





<span class="label label-default tag-lists">Tags</span>
	<a href="http://peter14f.github.io/pelican-blog/tag/binary-search-trees.html">Binary Search Trees</a>
        /
	<a href="http://peter14f.github.io/pelican-blog/tag/common-ancestor.html">Common Ancestor</a>
    
</footer><!-- /.post-info -->                    </div>
                <div class="summary article-summary"><p><a class="reference external" href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">LeetCode Problem Link</a></p>
<p>This problem would be a lot more difficult if we need to check if <tt class="docutils literal">p</tt> and <tt class="docutils literal">q</tt> are actually in the BST.</p>
<p>But the problem statement states that the two given nodes are in the BST.</p>
<p>So we can simply use recursion and the property of a BST.</p>
<div class="highlight"><pre> <span class="kd">public</span> <span class="n">TreeNode</span> <span class="nf">lowestCommonAncestor</span><span class="o">(</span>
        <span class="n">TreeNode</span> <span class="n">root</span><span class="o">,</span>
        <span class="n">TreeNode</span> <span class="n">p</span><span class="o">,</span>
        <span class="n">TreeNode</span> <span class="n">q</span><span class="o">)</span> <span class="o">{</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">val</span> <span class="o">&lt;=</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span> <span class="o">&amp;&amp;</span> <span class="n">q</span><span class="o">.</span><span class="na">val</span> <span class="o">&gt;=</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">val</span> <span class="o">&lt;</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span> <span class="o">&amp;&amp;</span> <span class="n">q</span><span class="o">.</span><span class="na">val</span> <span class="o">&lt;</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">lowestCommonAncestor</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="n">q</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">val</span> <span class="o">&gt;</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span> <span class="o">&amp;&amp;</span> <span class="n">q</span><span class="o">.</span><span class="na">val ...</span></pre></div>
                    <a class="btn btn-default btn-xs" href="http://peter14f.github.io/pelican-blog/235-lowest_common_ancestor_of_a_binary_search_tree.html">more ...</a>
                </div>
            </article>
            <hr/>
            <article>
                <h2 class="article-title"><a href="http://peter14f.github.io/pelican-blog/binary_search_tree_deletion.html">binary_search_tree_deletion</a></h2>
                    <div>
<footer class="post-info">
    <span class="published label label-default">
        <time datetime="2016-02-10T23:07:00-08:00"> Feb 10 2016</time>
    </span>





<span class="label label-default tag-lists">Tags</span>
	<a href="http://peter14f.github.io/pelican-blog/tag/binary-search-trees.html">Binary Search Trees</a>
    
</footer><!-- /.post-info -->                    </div>
                <div class="summary article-summary"><p>While doing the problem 230-kth_smallest_element_in_a_bst, I realized I was forgetting what to do when
trying to delete from a BST.</p>
<p>Deleting leaf nodes are trivial. Deleting nodes with only one child is also trivial.</p>
<p>What happens when we need to delete a node with two children?</p>
<p>What we have to remember is that for any given node in a BST, the two values closest to it is the largest value
in its left subtree and the smallest value in its right subtree.</p>
<p>Replace the node's value with either of the two first, and then look for the replaced node ...</p>
                    <a class="btn btn-default btn-xs" href="http://peter14f.github.io/pelican-blog/binary_search_tree_deletion.html">more ...</a>
                </div>
            </article>
            <hr/>
            <article>
                <h2 class="article-title"><a href="http://peter14f.github.io/pelican-blog/230-kth_smallest_element_in_a_bst.html">230-kth_smallest_element_in_a_bst</a></h2>
                    <div>
<footer class="post-info">
    <span class="published label label-default">
        <time datetime="2016-02-10T18:27:00-08:00"> Feb 10 2016</time>
    </span>





<span class="label label-default tag-lists">Tags</span>
	<a href="http://peter14f.github.io/pelican-blog/tag/binary-search-trees.html">Binary Search Trees</a>
        /
	<a href="http://peter14f.github.io/pelican-blog/tag/recursion.html">Recursion</a>
    
</footer><!-- /.post-info -->                    </div>
                <div class="summary article-summary"><p><a class="reference external" href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/">LeetCode Problem Link</a></p>
<p>I use recursion to solve the original problem. In the method, I find the size of the left subtree first. If the left
subtree has a size of <tt class="docutils literal">l</tt> and <tt class="docutils literal">k</tt> happens to be <tt class="docutils literal">l+1</tt>, then we know the root is the answer. If <tt class="docutils literal"><span class="pre">k&lt;=l</span></tt>, then
we know the answer is in the left subtree. If <tt class="docutils literal">k &gt; l+1</tt>, then we know the answer is in the right subtree.</p>
<div class="highlight"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">kthSmallest</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">leftSize</span> <span class="o">=</span> <span class="n">getTreeSize</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">leftSize</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">k</span><span class="o">)</span>
        <span class="k">return</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">&lt;=</span> <span class="n">leftSize</span><span class="o">)</span>
        <span class="k">return</span> <span class="n">kthSmallest</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left ...</span></pre></div>
                    <a class="btn btn-default btn-xs" href="http://peter14f.github.io/pelican-blog/230-kth_smallest_element_in_a_bst.html">more ...</a>
                </div>
            </article>
            <hr/>
            <article>
                <h2 class="article-title"><a href="http://peter14f.github.io/pelican-blog/173-binary_search_tree_iterator.html">173-binary_search_tree_iterator</a></h2>
                    <div>
<footer class="post-info">
    <span class="published label label-default">
        <time datetime="2016-01-17T23:31:00-08:00"> Jan 17 2016</time>
    </span>





<span class="label label-default tag-lists">Tags</span>
	<a href="http://peter14f.github.io/pelican-blog/tag/binary-search-trees.html">Binary Search Trees</a>
    
</footer><!-- /.post-info -->                    </div>
                <div class="summary article-summary"><p><a class="reference external" href="https://leetcode.com/problems/binary-search-tree-iterator/">LeetCode Problem Link</a></p>
<p>We asked to implement the inorder traversal iterator of a binary tree.
The only field the Iterator needs is a Stack.</p>
<div class="highlight"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BSTIterator</span> <span class="o">{</span>
    <span class="n">Stack</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">stk</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">BSTIterator</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">stk</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;();</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">root</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">stk</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/** @return whether we have a next smallest number */</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasNext</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="o">!</span><span class="n">stk</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="cm">/** @return the next smallest number */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">next</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">TreeNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">stk</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
        <span class="n">TreeNode</span> <span class="n">t</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">t</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">stk</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>

                    <a class="btn btn-default btn-xs" href="http://peter14f.github.io/pelican-blog/173-binary_search_tree_iterator.html">more ...</a>
                </div>
            </article>
            <hr/>
            <article>
                <h2 class="article-title"><a href="http://peter14f.github.io/pelican-blog/109-convert_sorted_list_to_binary_search_tree.html">109-convert_sorted_list_to_binary_search_tree</a></h2>
                    <div>
<footer class="post-info">
    <span class="published label label-default">
        <time datetime="2015-11-26T22:40:00-08:00"> Nov 26 2015</time>
    </span>





<span class="label label-default tag-lists">Tags</span>
	<a href="http://peter14f.github.io/pelican-blog/tag/binary-search-trees.html">Binary Search Trees</a>
        /
	<a href="http://peter14f.github.io/pelican-blog/tag/recursion.html">Recursion</a>
    
</footer><!-- /.post-info -->                    </div>
                <div class="summary article-summary"><p><a class="reference external" href="https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/">LeetCode Problem Link</a></p>
<p>The top to bottom recursive approach is trivial. At the beginning of each call, we have to get to the middle of
list. So the time complexity is O(nlogn).</p>
<div class="highlight"><pre><span class="c1">// convert it to a height balanced BST</span>
<span class="kd">public</span> <span class="n">TreeNode</span> <span class="nf">sortedListToBST</span><span class="o">(</span><span class="n">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>

    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="n">ListNode</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>

    <span class="k">do</span> <span class="o">{</span>
        <span class="n">n</span><span class="o">++;</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">while</span> <span class="o">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">);</span>

    <span class="kt">int</span> <span class="n">steps</span> <span class="o">=</span> <span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="o">;</span>

    <span class="n">cur</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>

    <span class="n">ListNode</span> <span class="n">prev</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">steps</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="n">TreeNode</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">prev</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">prev</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">sortedListToBST ...</span></pre></div>
                    <a class="btn btn-default btn-xs" href="http://peter14f.github.io/pelican-blog/109-convert_sorted_list_to_binary_search_tree.html">more ...</a>
                </div>
            </article>
            <hr/>

        <ul class="pagination">
                <li class="prev disabled"><a href="#">&laquo;</a></li>
                    <li class="active"><a
                            href="http://peter14f.github.io/pelican-blog/tag/binary-search-trees.html">1</a></li>
                    <li class=""><a
                            href="http://peter14f.github.io/pelican-blog/tag/binary-search-trees2.html">2</a></li>
                <li class="next"><a
                        href="http://peter14f.github.io/pelican-blog/tag/binary-search-trees2.html">&raquo;</a></li>
        </ul>
        </div>
    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">&copy; 2016 Peter Hsieh
            &middot; Powered by <a href="https://github.com/DandyDev/pelican-bootstrap3" target="_blank">pelican-bootstrap3</a>,
            <a href="http://docs.getpelican.com/" target="_blank">Pelican</a>,
            <a href="http://getbootstrap.com" target="_blank">Bootstrap</a>         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="http://peter14f.github.io/pelican-blog/theme/js/jquery.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="http://peter14f.github.io/pelican-blog/theme/js/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->
<script src="http://peter14f.github.io/pelican-blog/theme/js/respond.min.js"></script>


</body>
</html>