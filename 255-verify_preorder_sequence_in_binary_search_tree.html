<!DOCTYPE html>
<html lang="en" prefix="og: http://ogp.me/ns# fb: https://www.facebook.com/2008/fbml">
<head>
    <title>255-verify_preorder_sequence_in_binary_search_tree - Peter's Coding Notes</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">



<link rel="canonical" href="http://peter14f.github.io/pelican-blog/255-verify_preorder_sequence_in_binary_search_tree.html">

        <meta name="author" content="Peter Hsieh" />
        <meta name="keywords" content="Binary Search Trees,Inorder Traversal" />
        <meta name="description" content="LeetCode Problem Link In a preorder traversal sequence, the first element is always the root. The first element you find that is greater than root marks the beginning of the right subtree. All elements starting from it must be greater than root. Then we must use recursion to check the left subtree and the right subtree. // could assume each number in the sequence is unique public boolean verifyPreorder(int[] preorder) { if (preorder.length == 0) return true; return isPreorder(preorder, 0, preorder.length - 1); } private boolean isPreorder(int[] preorder, int start, int end) { if (start==end) return true; int root = preorder ..." />

        <meta property="og:site_name" content="Peter's Coding Notes" />
        <meta property="og:type" content="article"/>
        <meta property="og:title" content="255-verify_preorder_sequence_in_binary_search_tree"/>
        <meta property="og:url" content="http://peter14f.github.io/pelican-blog/255-verify_preorder_sequence_in_binary_search_tree.html"/>
        <meta property="og:description" content="LeetCode Problem Link In a preorder traversal sequence, the first element is always the root. The first element you find that is greater than root marks the beginning of the right subtree. All elements starting from it must be greater than root. Then we must use recursion to check the left subtree and the right subtree. // could assume each number in the sequence is unique public boolean verifyPreorder(int[] preorder) { if (preorder.length == 0) return true; return isPreorder(preorder, 0, preorder.length - 1); } private boolean isPreorder(int[] preorder, int start, int end) { if (start==end) return true; int root = preorder ..."/>
        <meta property="article:published_time" content="2016-02-18" />
            <meta property="article:section" content="LeetCode" />
            <meta property="article:tag" content="Binary Search Trees" />
            <meta property="article:tag" content="Inorder Traversal" />
            <meta property="article:author" content="Peter Hsieh" />


    <!-- Bootstrap -->
        <link rel="stylesheet" href="http://peter14f.github.io/pelican-blog/theme/css/bootstrap.min.css" type="text/css"/>
    <link href="http://peter14f.github.io/pelican-blog/theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="http://peter14f.github.io/pelican-blog/theme/css/pygments/native.css" rel="stylesheet">
    <link rel="stylesheet" href="http://peter14f.github.io/pelican-blog/theme/css/style.css" type="text/css"/>

        <link href="http://peter14f.github.io/pelican-blog/feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="Peter's Coding Notes ATOM Feed"/>



        <link href="http://peter14f.github.io/pelican-blog/feeds/leetcode.atom.xml" type="application/atom+xml" rel="alternate"
              title="Peter's Coding Notes LeetCode ATOM Feed"/>

</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
	<div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="http://peter14f.github.io/pelican-blog/" class="navbar-brand">
Peter's Coding Notes            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                        <li class="active">
                            <a href="http://peter14f.github.io/pelican-blog/category/leetcode.html">Leetcode</a>
                        </li>
                        <li >
                            <a href="http://peter14f.github.io/pelican-blog/category/misc.html">Misc</a>
                        </li>
                        <li >
                            <a href="http://peter14f.github.io/pelican-blog/category/more-questions.html">More questions</a>
                        </li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
              <li><a href="http://peter14f.github.io/pelican-blog/archives.html"><i class="fa fa-th-list"></i><span class="icon-label">Archives</span></a></li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->
<!-- Banner -->
<!-- End Banner -->
<div class="container">
    <div class="row">
        <div class="col-lg-12">
    <section id="content">
        <article>
                <h2>
                    <a href="http://peter14f.github.io/pelican-blog/255-verify_preorder_sequence_in_binary_search_tree.html"
                       rel="bookmark"
                       title="Permalink to 255-verify_preorder_sequence_in_binary_search_tree">
                        255-verify_preorder_sequence_in_binary_search_tree
                    </a>
                </h2>
            <div class="entry-content">
<footer class="post-info">
    <span class="published label label-default">
        <time datetime="2016-02-18T13:34:00-08:00"> Feb 18 2016</time>
    </span>





<span class="label label-default tag-lists">Tags</span>
	<a href="http://peter14f.github.io/pelican-blog/tag/binary-search-trees.html">Binary Search Trees</a>
        /
	<a href="http://peter14f.github.io/pelican-blog/tag/inorder-traversal.html">Inorder Traversal</a>
    
</footer><!-- /.post-info -->                <div class="full-article">
                <p><a class="reference external" href="https://leetcode.com/problems/verify-preorder-sequence-in-binary-search-tree/">LeetCode Problem Link</a></p>
<p>In a preorder traversal sequence, the first element is always the root. The first element you find that is greater
than root marks the beginning of the right subtree. All elements starting from it must be greater than root. Then
we must use recursion to check the left subtree and the right subtree.</p>
<div class="highlight"><pre><span class="c1">// could assume each number in the sequence is unique</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">verifyPreorder</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">preorder</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">preorder</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>

    <span class="k">return</span> <span class="n">isPreorder</span><span class="o">(</span><span class="n">preorder</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">preorder</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isPreorder</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">preorder</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">start</span><span class="o">==</span><span class="n">end</span><span class="o">)</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>

    <span class="kt">int</span> <span class="n">root</span> <span class="o">=</span> <span class="n">preorder</span><span class="o">[</span><span class="n">start</span><span class="o">];</span>
    <span class="kt">boolean</span> <span class="n">checkLeftSubtree</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="kt">boolean</span> <span class="n">checkRightSubtree</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

    <span class="kt">int</span> <span class="n">rightChildIndex</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">start</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">end</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">preorder</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">rightChildIndex</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
            <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">rightChildIndex</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// everyone behind root is in the left subtree</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">start</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="o">)</span>
            <span class="n">checkLeftSubtree</span> <span class="o">=</span> <span class="n">isPreorder</span><span class="o">(</span><span class="n">preorder</span><span class="o">,</span> <span class="n">start</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">end</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">else</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">rightChildIndex</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;=</span><span class="n">end</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">preorder</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">root</span><span class="o">)</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">start</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">rightChildIndex</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span>
            <span class="n">checkLeftSubtree</span> <span class="o">=</span> <span class="n">isPreorder</span><span class="o">(</span><span class="n">preorder</span><span class="o">,</span> <span class="n">start</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">rightChildIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">rightChildIndex</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="o">)</span>
            <span class="n">checkRightSubtree</span> <span class="o">=</span> <span class="n">isPreorder</span><span class="o">(</span><span class="n">preorder</span><span class="o">,</span> <span class="n">rightChildIndex</span><span class="o">,</span> <span class="n">end</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">checkLeftSubtree</span> <span class="o">&amp;&amp;</span> <span class="n">checkRightSubtree</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>
<p>This approach is not O(1) space that since the calls on the call stack counts toward memory usage as well.</p>
<p>Actually we can improve the part where we make sure nodes beyond the right child are all bigger using recursion
as well.</p>
<div class="highlight"><pre><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">verifyPreorder</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">preorder</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">preorder</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>

    <span class="k">return</span> <span class="n">isPreorder</span><span class="o">(</span><span class="n">preorder</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">preorder</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span>
                      <span class="n">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">,</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isPreorder</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">preorder</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">,</span>
                           <span class="kt">int</span> <span class="n">min</span><span class="o">,</span> <span class="kt">int</span> <span class="n">max</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">end</span><span class="o">)</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>

    <span class="kt">int</span> <span class="n">root</span> <span class="o">=</span> <span class="n">preorder</span><span class="o">[</span><span class="n">start</span><span class="o">];</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">&gt;</span> <span class="n">max</span> <span class="o">||</span> <span class="n">root</span> <span class="o">&lt;</span> <span class="n">min</span><span class="o">)</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>

    <span class="kt">int</span> <span class="n">rightChildIndex</span> <span class="o">=</span> <span class="n">start</span><span class="o">;</span>

    <span class="k">while</span> <span class="o">(</span><span class="n">rightChildIndex</span> <span class="o">&lt;=</span> <span class="n">end</span> <span class="o">&amp;&amp;</span> <span class="n">preorder</span><span class="o">[</span><span class="n">rightChildIndex</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">rightChildIndex</span><span class="o">++;</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">isPreorder</span><span class="o">(</span><span class="n">preorder</span><span class="o">,</span> <span class="n">start</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">rightChildIndex</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">min</span><span class="o">,</span> <span class="n">root</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
            <span class="n">isPreorder</span><span class="o">(</span><span class="n">preorder</span><span class="o">,</span> <span class="n">rightChildIndex</span><span class="o">,</span> <span class="n">end</span><span class="o">,</span> <span class="n">root</span><span class="o">,</span> <span class="n">max</span><span class="o">);</span>
<span class="o">}</span>
</pre></div>
<p>Here's an approach using a stack. <tt class="docutils literal">low</tt> is the lower limit for future nodes. If we see any node smaller
thatn <tt class="docutils literal">low</tt> then return <tt class="docutils literal">false</tt></p>
<p>Smaller then top of stack, just push. When a bigger than top number is seen, pop until a larger number is found, and
update the new <tt class="docutils literal">low</tt>.</p>
<div class="highlight"><pre><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">verifyPreorder</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">preorder</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">preorder</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>

    <span class="kt">int</span> <span class="n">low</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">;</span>
    <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">stk</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">preorder</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">preorder</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">low</span><span class="o">)</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>

        <span class="k">while</span> <span class="o">(!</span><span class="n">stk</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">preorder</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">stk</span><span class="o">.</span><span class="na">peek</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">low</span> <span class="o">=</span> <span class="n">stk</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="n">stk</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">preorder</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>
<p>Well this still take O(n) space. We can use the input array <tt class="docutils literal">preorder</tt> for the stack and achieve
constant space.</p>
<div class="highlight"><pre><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">verifyPreorder</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">preorder</span><span class="o">)</span> <span class="o">{</span>

    <span class="kt">int</span> <span class="n">top</span><span class="o">=-</span><span class="mi">1</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">low</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">;</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">preorder</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">preorder</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">low</span><span class="o">)</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">top</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">preorder</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">preorder</span><span class="o">[</span><span class="n">top</span><span class="o">])</span> <span class="o">{</span>
            <span class="n">low</span> <span class="o">=</span> <span class="n">preorder</span><span class="o">[</span><span class="n">top</span><span class="o">];</span>
            <span class="n">top</span><span class="o">--;</span>
        <span class="o">}</span>

        <span class="c1">// push</span>
        <span class="n">preorder</span><span class="o">[++</span><span class="n">top</span><span class="o">]</span> <span class="o">=</span> <span class="n">preorder</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>

                </div>
            </div>
            <!-- /.entry-content -->
        </article>
    </section>

        </div>
    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">&copy; 2016 Peter Hsieh
            &middot; Powered by <a href="https://github.com/DandyDev/pelican-bootstrap3" target="_blank">pelican-bootstrap3</a>,
            <a href="http://docs.getpelican.com/" target="_blank">Pelican</a>,
            <a href="http://getbootstrap.com" target="_blank">Bootstrap</a>         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="http://peter14f.github.io/pelican-blog/theme/js/jquery.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="http://peter14f.github.io/pelican-blog/theme/js/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->
<script src="http://peter14f.github.io/pelican-blog/theme/js/respond.min.js"></script>


</body>
</html>